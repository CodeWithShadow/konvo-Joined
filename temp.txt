'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KONVO - SECURE CHAT APPLICATION v2.0
// Security Hardened Version
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRODUCTION CONSOLE CONTROL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DEBUG_MODE = false; // Set to true for development

if (!DEBUG_MODE) {
  const noop = () => {};
  const methods = [
    'log', 'warn', 'info', 'debug', 'trace', 'dir',
    'dirxml', 'table', 'group', 'groupEnd', 'groupCollapsed',
    'time', 'timeEnd', 'timeLog', 'count', 'countReset', 'clear'
  ];
  methods.forEach(method => { console[method] = noop; });
  // Keep console.error for critical issues
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOBILE VIEWPORT HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(function setupMobileViewport() {
  let pendingUpdate = false;

  const apply = () => {
    if (pendingUpdate) return;
    pendingUpdate = true;

    requestAnimationFrame(() => {
      const viewport = window.visualViewport;
      const height = viewport?.height || window.innerHeight;
      const offsetTop = viewport?.offsetTop || 0;

      document.documentElement.style.setProperty('--app-height', `${height}px`);
      document.documentElement.style.setProperty('--viewport-offset', `${offsetTop}px`);

      if (document.body) {
        document.body.style.height = `${height}px`;
        document.body.style.maxHeight = `${height}px`;
      }

      if (typeof state !== 'undefined' && state?.userIsAtBottom && typeof feedContainer !== 'undefined' && feedContainer) {
        feedContainer.scrollTop = feedContainer.scrollHeight;
      }

      pendingUpdate = false;
    });
  };

  apply();

  let resizeTimeout;
  const debouncedApply = () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(apply, 50);
  };

  window.addEventListener('resize', debouncedApply, { passive: true });

  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', apply, { passive: true });
    window.visualViewport.addEventListener('scroll', apply, { passive: true });
  }

  window.addEventListener('orientationchange', () => {
    setTimeout(apply, 100);
  }, { passive: true });
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIREBASE IMPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js";
import {
  initializeFirestore,
  persistentLocalCache,
  persistentMultipleTabManager,
  collection,
  addDoc,
  onSnapshot,
  query,
  serverTimestamp,
  doc,
  setDoc,
  getDoc,
  getDocs,
  where,
  orderBy,
  limit,
  startAfter,
  updateDoc,
  deleteDoc,
  writeBatch,
  arrayUnion,
  arrayRemove,
  increment,
  Timestamp,
} from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";
import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-functions.js";

// Optional: Firebase App Check for bot prevention
// import { initializeAppCheck, ReCaptchaV3Provider } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app-check.js";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const REACTION_TYPES = Object.freeze({
  thumbsup: "ğŸ‘",
  laugh: "ğŸ˜‚",
  surprised: "ğŸ˜®",
  heart: "â¤ï¸",
  skull: "ğŸ’€"
});

const USER_COLORS = Object.freeze([
  "#ff79c6", "#8be9fd", "#50fa7b", "#bd93f9", "#ffb86c",
  "#f1fa8c", "#ff5555", "#00e5ff", "#fab1a0", "#a29bfe",
  "#55efc4", "#fdcb6e", "#e17055", "#d63031", "#e84393",
  "#0984e3", "#00b894"
]);

const CONFIG = Object.freeze({
  MESSAGE_MAX_LENGTH: 500,
  USERNAME_MAX_LENGTH: 30,
  USERNAME_MIN_LENGTH: 1,
  TYPING_TIMEOUT: 3000,
  TYPING_STALE_THRESHOLD: 5000,
  FINGERPRINT_STORAGE_KEY: 'konvo_device_fp',
  MESSAGES_PER_PAGE: 50,
  MAX_MESSAGES_LOADED: 500,
  REACTION_COOLDOWN_MS: 1000,
  TYPING_COOLDOWN_MS: 500,
  MESSAGE_COOLDOWN_MS: 2000,
  REQUEST_TIMEOUT_MS: 15000,
  PROFILE_BATCH_SIZE: 30,
  SCROLL_THRESHOLD: 100,
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIREBASE CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const firebaseConfig = {
  apiKey: "AIzaSyA44_Aq1LBil6LFHcTltRI6vS5E0ilHfLQ",
  authDomain: "konvo-f1.firebaseapp.com",
  projectId: "konvo-f1",
  storageBucket: "konvo-f1.firebasestorage.app",
  messagingSenderId: "114064168714",
  appId: "1:114064168714:web:7efb45d46b42cb93204cf3"
};

const appStartTime = Date.now();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// APPLICATION STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const state = {
  // Firebase instances
  app: null,
  db: null,
  auth: null,
  functions: null,

  // Cloud Functions
  sendMessageFn: null,
  setUsernameFn: null,

  // User state
  currentUserId: null,
  currentUsername: "Anonymous",
  currentProfilePhotoURL: null,
  isCurrentUserAdmin: false,

  // Device info
  deviceInfo: null,

  // Ban state
  isBanned: false,
  isDeviceBanned: false,

  // User profiles cache
  userProfiles: {},
  pendingProfileLoads: new Set(),
  profileLoadTimeout: null,

  // Message state
  lastConfessionDocs: [],
  lastChatDocs: [],
  lastVisibleMessage: null,
  isLoadingMore: false,
  hasMoreMessages: true,

  // Collections
  confessionsCollection: null,
  chatCollection: null,
  typingStatusCollection: null,

  // UI state
  currentPage: "chat",
  isSelectionMode: false,
  selectedMessages: new Set(),
  currentContextMenuData: null,
  replyToMessage: null,

  // Notifications
  notificationsEnabled: false,
  unreadMessages: 0,

  // Scroll
  userIsAtBottom: true,
  bottomObserver: null,

  // Edit state
  docToEditId: null,
  collectionToEdit: null,

  // Typing
  typingTimeout: null,
  lastTypingUpdate: 0,

  // Rate limiting (client-side additional layer)
  lastMessageTime: 0,
  lastReactionTime: 0,

  // Init flag
  isInitialized: false,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LISTENER UNSUBSCRIBERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const unsubscribers = {
  confessions: null,
  chat: null,
  userProfiles: null,
  typingStatus: null,
  pinned: null,
  banCheck: null,
  deviceBanCheck: null,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOM ELEMENT REFERENCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const elements = {
  feedContainer: document.getElementById("feedContainer"),
  loading: document.getElementById("loading"),
  navConfessions: document.getElementById("navConfessions"),
  navChat: document.getElementById("navChat"),
  confessionForm: document.getElementById("confessionForm"),
  confessionInput: document.getElementById("confessionInput"),
  chatForm: document.getElementById("chatForm"),
  chatInput: document.getElementById("chatInput"),
  chatCharCount: document.getElementById("chatCharCount"),
  confessionCharCount: document.getElementById("confessionCharCount"),
  typingIndicator: document.getElementById("typingIndicator"),
  pinnedMessageBar: document.getElementById("pinnedMessageBar"),
  pinnedMessageText: document.getElementById("pinnedMessageText"),
  scrollToBottomBtn: document.getElementById("scrollToBottomBtn"),
  newMsgCount: document.getElementById("newMsgCount"),
  profileButton: document.getElementById("profileButton"),
  notificationButton: document.getElementById("notificationButton"),
  profileModal: document.getElementById("profileModal"),
  modalCloseButton: document.getElementById("modalCloseButton"),
  modalSaveButton: document.getElementById("modalSaveButton"),
  modalUsernameInput: document.getElementById("modalUsernameInput"),
  editModal: document.getElementById("editModal"),
  modalEditTextArea: document.getElementById("modalEditTextArea"),
  editModalCancelButton: document.getElementById("editModalCancelButton"),
  editModalSaveButton: document.getElementById("editModalSaveButton"),
  confirmModal: document.getElementById("confirmModal"),
  confirmModalText: document.getElementById("confirmModalText"),
  confirmModalNoButton: document.getElementById("confirmModalNoButton"),
  confirmModalActionContainer: document.getElementById("confirmModalActionContainer"),
  contextMenu: document.getElementById("contextMenu"),
  menuEdit: document.getElementById("menuEdit"),
  menuDelete: document.getElementById("menuDelete"),
  menuSelect: document.getElementById("menuSelect"),
  selectionBar: document.getElementById("selectionBar"),
  selectionCount: document.getElementById("selectionCount"),
  selectionCancel: document.getElementById("selectionCancel"),
  selectionDelete: document.getElementById("selectionDelete"),
  replyBar: document.getElementById("replyBar"),
  replyAuthor: document.getElementById("replyAuthor"),
  replyText: document.getElementById("replyText"),
  cancelReply: document.getElementById("cancelReply"),
};

// Destructure for easier access
const {
  feedContainer, loading, navConfessions, navChat,
  confessionForm, confessionInput, chatForm, chatInput,
  chatCharCount, confessionCharCount,
  typingIndicator, pinnedMessageBar, pinnedMessageText,
  scrollToBottomBtn, newMsgCount, profileButton, notificationButton,
  profileModal, modalCloseButton, modalSaveButton, modalUsernameInput,
  editModal, modalEditTextArea, editModalCancelButton, editModalSaveButton,
  confirmModal, confirmModalText, confirmModalNoButton, confirmModalActionContainer,
  contextMenu, menuEdit, menuDelete, menuSelect,
  selectionBar, selectionCount, selectionCancel, selectionDelete,
  replyBar, replyAuthor, replyText, cancelReply
} = elements;

// Admin menu items (created dynamically)
let menuPin = null;
let menuBan = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILITY FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Promise with timeout
 */
function withTimeout(promise, ms, fallbackValue = null) {
  return Promise.race([
    promise,
    new Promise((resolve) => setTimeout(() => resolve(fallbackValue), ms))
  ]);
}

/**
 * Debounce function
 */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Throttle function
 */
function throttle(func, limit) {
  let inThrottle;
  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

/**
 * Escape CSS selector
 */
function escapeSelector(selector) {
  if (typeof selector !== 'string') return '';
  return CSS.escape(selector);
}

/**
 * Safe text content setter
 */
function setTextSafely(element, text) {
  if (element && element instanceof HTMLElement) {
    element.textContent = text || '';
  }
}

/**
 * Create safe text node
 */
function createSafeTextNode(text) {
  return document.createTextNode(text || '');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEXT SANITIZATION & VALIDATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Sanitize text for display
 */
function sanitizeText(text) {
  if (typeof text !== 'string') return '';
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\r?\n/g, ' ')
    .replace(/`/g, '&#x60;');
}

/**
 * Validate username
 */
function isValidUsername(username) {
  if (typeof username !== 'string') return false;
  const trimmed = username.trim();

  if (trimmed.length < CONFIG.USERNAME_MIN_LENGTH ||
    trimmed.length > CONFIG.USERNAME_MAX_LENGTH) return false;

  const reserved = [
    'anonymous', 'admin', 'moderator', 'system', 'konvo', 'mod',
    'support', 'staff', 'official', 'root', 'owner', 'bot', 'help'
  ];

  const lowerUsername = trimmed.toLowerCase();

  if (reserved.some(r => lowerUsername === r || lowerUsername.includes(r))) {
    return false;
  }

  const usernameRegex = /^[A-Za-z0-9_\- ]+$/;
  if (!usernameRegex.test(trimmed)) return false;

  if (trimmed.startsWith(' ') || trimmed.endsWith(' ')) return false;

  return true;
}

/**
 * Validate message text
 */
function isValidMessageText(text) {
  if (typeof text !== 'string') return false;
  const trimmed = text.trim();

  if (trimmed.length === 0 || trimmed.length > CONFIG.MESSAGE_MAX_LENGTH) return false;

  const controlCharRegex = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/;
  return !controlCharRegex.test(trimmed);
}

/**
 * Validate profile photo URL
 */
function isValidProfilePhotoURL(url) {
  if (typeof url !== 'string') return false;
  if (url.length > 500) return false;

  const allowedPatterns = [
    /^https:\/\/placehold\.co\/.+$/,
    /^https:\/\/ui-avatars\.com\/.+$/,
    /^https:\/\/api\.dicebear\.com\/.+$/,
  ];

  return allowedPatterns.some(pattern => pattern.test(url));
}

/**
 * Validate message before posting
 */
function validateMessageBeforePost(text) {
  if (typeof text !== 'string') {
    return { valid: false, error: "Invalid message format" };
  }

  const trimmed = text.trim();

  if (trimmed.length === 0) {
    return { valid: false, error: "Message cannot be empty" };
  }

  if (trimmed.length > CONFIG.MESSAGE_MAX_LENGTH) {
    return { valid: false, error: `Message too long (max ${CONFIG.MESSAGE_MAX_LENGTH} characters)` };
  }

  const controlCharRegex = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/;
  if (controlCharRegex.test(trimmed)) {
    return { valid: false, error: "Message contains invalid characters" };
  }

  return { valid: true, text: trimmed };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Get consistent color for user
 */
function getUserColor(userId) {
  if (!userId || typeof userId !== 'string') return USER_COLORS[0];
  let hash = 0;
  for (let i = 0; i < userId.length; i++) {
    hash = userId.charCodeAt(i) + ((hash << 5) - hash);
  }
  const index = Math.abs(hash % USER_COLORS.length);
  return USER_COLORS[index];
}

/**
 * Format message timestamp
 */
function formatMessageTime(date) {
  if (!(date instanceof Date) || isNaN(date)) {
    return 'Just now';
  }

  const diff = Date.now() - date.getTime();
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);

  if (minutes < 1) return "Just now";
  if (minutes < 5) return `${minutes} mins ago`;

  return date.toLocaleTimeString([], {
    hour: "2-digit",
    minute: "2-digit",
    hour12: false
  });
}

/**
 * Get date header text
 */
function getDateHeader(date) {
  if (!(date instanceof Date) || isNaN(date)) {
    return 'Today';
  }

  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  if (date.toDateString() === today.toDateString()) return "Today";
  if (date.toDateString() === yesterday.toDateString()) return "Yesterday";

  return date.toLocaleDateString([], {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric'
  });
}

/**
 * Show toast notification
 */
function showToast(message, type = 'info') {
  const existingToast = document.getElementById('app-toast');
  if (existingToast) existingToast.remove();

  const toast = document.createElement('div');
  toast.id = 'app-toast';
  toast.style.cssText = `
    position: fixed;
    top: 70px;
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 14px;
    z-index: 10000;
    text-align: center;
    max-width: 90%;
    animation: slideDown 0.3s ease-out;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  `;

  if (type === 'error') {
    toast.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a5a)';
    toast.style.color = 'white';
  } else if (type === 'warning') {
    toast.style.background = 'linear-gradient(135deg, #ffa726, #fb8c00)';
    toast.style.color = 'white';
  } else {
    toast.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
    toast.style.color = 'white';
  }

  toast.textContent = message;
  document.body.appendChild(toast);

  setTimeout(() => {
    if (toast.parentNode) {
      toast.style.animation = 'fadeOut 0.3s ease-out forwards';
      setTimeout(() => toast.remove(), 300);
    }
  }, 4000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FINGERPRINT GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Generate device fingerprint
 */
async function generateDeviceFingerprint() {
  // Try to get saved fingerprint first
  try {
    const savedFingerprint = localStorage.getItem(CONFIG.FINGERPRINT_STORAGE_KEY);
    if (savedFingerprint && savedFingerprint.length > 0) {
      return savedFingerprint;
    }
  } catch (e) {
    // localStorage not available
  }

  try {
    if (typeof FingerprintJS !== 'undefined') {
      const fp = await withTimeout(FingerprintJS.load(), 5000, null);
      if (fp) {
        const result = await withTimeout(fp.get(), 5000, null);
        if (result && result.visitorId) {
          saveFingerprint(result.visitorId);
          return result.visitorId;
        }
      }
    }
  } catch (error) {
    // FingerprintJS failed, use fallback
  }

  return createStableFallbackFingerprint();
}

/**
 * Create stable fallback fingerprint
 */
function createStableFallbackFingerprint() {
  try {
    const saved = localStorage.getItem(CONFIG.FINGERPRINT_STORAGE_KEY);
    if (saved && saved.length > 0) return saved;
  } catch (e) { }

  const components = [
    navigator.userAgent,
    navigator.language,
    screen.width + 'x' + screen.height,
    screen.colorDepth,
    new Date().getTimezoneOffset(),
    navigator.hardwareConcurrency || 'unknown',
    navigator.deviceMemory || 'unknown',
    navigator.platform,
  ];

  let hash = 0;
  const str = components.join('|||');
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }

  const randomPart = generateRandomString(8);
  const fallbackId = 'fb_' + Math.abs(hash).toString(36) + '_' + randomPart;

  saveFingerprint(fallbackId);
  return fallbackId;
}

/**
 * Generate random string
 */
function generateRandomString(length) {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';

  try {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    for (let i = 0; i < length; i++) {
      result += chars[array[i] % chars.length];
    }
    return result;
  } catch (e) {
    for (let i = 0; i < length; i++) {
      result += chars[Math.floor(Math.random() * chars.length)];
    }
    return result;
  }
}

/**
 * Save fingerprint to localStorage
 */
function saveFingerprint(fingerprint) {
  try {
    localStorage.setItem(CONFIG.FINGERPRINT_STORAGE_KEY, fingerprint);
  } catch (e) {
    // Could not save
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IP ADDRESS DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Get user IP address
 */
async function getUserIPAddress() {
  const ipServices = [
    'https://api.ipify.org?format=json',
    'https://ipapi.co/json/'
  ];

  try {
    const fetchPromises = ipServices.map(async (service) => {
      const response = await fetch(service, { mode: 'cors' });
      if (!response.ok) throw new Error('Failed');
      const data = await response.json();
      if (data.ip && isValidIP(data.ip)) {
        return data.ip;
      }
      throw new Error('Invalid IP');
    });

    const result = await withTimeout(
      Promise.any(fetchPromises),
      3000,
      null
    );

    return result;
  } catch (error) {
    return null;
  }
}

/**
 * Validate IP address format
 */
function isValidIP(ip) {
  if (!ip || typeof ip !== 'string') return false;
  const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;
  const ipv6Pattern = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^([0-9a-fA-F]{1,4}:)*:([0-9a-fA-F]{1,4}:)*[0-9a-fA-F]{1,4}$|^::$/;

  if (ipv4Pattern.test(ip)) {
    const parts = ip.split('.').map(Number);
    return parts.every(part => part >= 0 && part <= 255);
  }

  return ipv6Pattern.test(ip);
}

/**
 * Hash IP address
 */
function hashIP(ip) {
  if (!ip) return '';
  let hash = 0;
  for (let i = 0; i < ip.length; i++) {
    const char = ip.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return 'ip_' + Math.abs(hash).toString(36);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEVICE IDENTIFICATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Initialize device identification
 */
async function initializeDeviceIdentification() {
  try {
    const result = await withTimeout(
      Promise.all([
        generateDeviceFingerprint(),
        getUserIPAddress()
      ]),
      8000,
      null
    );

    if (!result) {
      return {
        fingerprint: createStableFallbackFingerprint(),
        ipAddress: null,
        ipHash: null,
        userAgent: navigator.userAgent,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screenResolution: `${screen.width}x${screen.height}`,
        platform: navigator.platform,
      };
    }

    const [fingerprint, ipAddress] = result;

    return {
      fingerprint,
      ipAddress,
      ipHash: hashIP(ipAddress),
      userAgent: navigator.userAgent,
      language: navigator.language,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      screenResolution: `${screen.width}x${screen.height}`,
      platform: navigator.platform,
    };

  } catch (error) {
    return {
      fingerprint: createStableFallbackFingerprint(),
      ipAddress: null,
      ipHash: null,
      userAgent: navigator.userAgent,
      language: navigator.language,
      timezone: null,
      screenResolution: `${screen.width}x${screen.height}`,
      platform: navigator.platform,
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BAN CHECKING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Check all ban types
 */
async function checkAllBans(db, userId, deviceInfo) {
  if (!db) return { isBanned: false };

  try {
    // Check user ban
    if (userId) {
      const userBanRef = doc(db, "banned_users", userId);
      const userBanSnap = await getDoc(userBanRef);
      if (userBanSnap.exists()) {
        return { isBanned: true, banType: 'user', reason: 'User banned' };
      }
    }

    // Check device fingerprint ban
    if (deviceInfo?.fingerprint) {
      const fpBanRef = doc(db, "banned_devices", deviceInfo.fingerprint);
      const fpBanSnap = await getDoc(fpBanRef);
      if (fpBanSnap.exists()) {
        return { isBanned: true, banType: 'device', reason: 'Device banned' };
      }
    }

    // Note: IP ban check is done implicitly when device registration fails

    return { isBanned: false };
  } catch (error) {
    console.error('Ban check error:', error);
    return { isBanned: false, error: error.message };
  }
}

/**
 * Register device with Firestore
 */
async function registerDevice(db, userId, deviceInfo) {
  if (!db || !userId || !deviceInfo?.fingerprint) return;

  try {
    const deviceDocId = `${userId}_${deviceInfo.fingerprint}`;
    const deviceRef = doc(db, "user_devices", deviceDocId);
    const deviceSnap = await getDoc(deviceRef);

    if (deviceSnap.exists()) {
      await updateDoc(deviceRef, {
        lastSeen: serverTimestamp(),
        ipAddress: deviceInfo.ipAddress || null,
        ipHash: deviceInfo.ipHash || null,
        userAgent: deviceInfo.userAgent || null,
      });
    } else {
      await setDoc(deviceRef, {
        userId: userId,
        fingerprint: deviceInfo.fingerprint,
        ipAddress: deviceInfo.ipAddress || null,
        ipHash: deviceInfo.ipHash || null,
        userAgent: deviceInfo.userAgent || null,
        language: deviceInfo.language || null,
        timezone: deviceInfo.timezone || null,
        screenResolution: deviceInfo.screenResolution || null,
        platform: deviceInfo.platform || null,
        firstSeen: serverTimestamp(),
        lastSeen: serverTimestamp(),
      });
    }
  } catch (error) {
    if (error.code === 'permission-denied') {
      state.isDeviceBanned = true;
      showDeviceBannedScreen('Device or IP is banned');
      throw error;
    }
    console.error('Device registration error:', error);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BAN UI FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Hide ban check overlay
 */
function hideBanCheckOverlay() {
  const overlay = document.getElementById('banCheckOverlay');
  if (overlay) {
    overlay.classList.add('hidden');
    setTimeout(() => {
      overlay.style.display = 'none';
    }, 300);
  }
}

/**
 * Show device banned screen
 */
function showDeviceBannedScreen(reason = 'Device banned') {
  const appContainer = document.getElementById('app') || document.body;

  Array.from(appContainer.children).forEach(child => {
    if (child.id !== 'banOverlayScreen') {
      child.style.display = 'none';
    }
  });

  const existingOverlay = document.getElementById('banOverlayScreen');
  if (existingOverlay) existingOverlay.remove();

  const existingCheck = document.getElementById('banCheckOverlay');
  if (existingCheck) existingCheck.style.display = 'none';

  const overlay = document.createElement('div');
  overlay.id = 'banOverlayScreen';
  overlay.style.cssText = `
    position: fixed;
    inset: 0;
    background-color: #0a0a0a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 99999;
    gap: 0.5rem;
    padding: 1rem;
  `;

  const h1 = document.createElement('h1');
  h1.style.cssText = 'font-size: 1.875rem; color: #ef4444; font-weight: bold;';
  h1.textContent = 'ğŸš« ACCESS DENIED';

  const p1 = document.createElement('p');
  p1.style.cssText = 'color: #888; font-size: 0.875rem;';
  p1.textContent = 'This device has been banned from Konvo.';

  const p2 = document.createElement('p');
  p2.style.cssText = 'color: #666; font-size: 0.75rem;';
  p2.textContent = 'Reason: ' + sanitizeText(reason);

  const p3 = document.createElement('p');
  p3.style.cssText = 'color: #555; font-size: 0.75rem; margin-top: 1rem;';
  p3.textContent = 'If you believe this is a mistake, please wait for admin review.';

  overlay.appendChild(h1);
  overlay.appendChild(p1);
  overlay.appendChild(p2);
  overlay.appendChild(p3);
  document.body.appendChild(overlay);
  document.body.classList.add('device-banned');
}

/**
 * Show user banned screen
 */
function showBannedScreen() {
  const appContainer = document.getElementById('app') || document.body;

  Array.from(appContainer.children).forEach(child => {
    if (child.id !== 'banOverlayScreen') {
      child.style.display = 'none';
    }
  });

  const existingOverlay = document.getElementById('banOverlayScreen');
  if (existingOverlay) existingOverlay.remove();

  const overlay = document.createElement('div');
  overlay.id = 'banOverlayScreen';
  overlay.className = 'banned-overlay';
  overlay.style.cssText = `
    position: fixed;
    inset: 0;
    background-color: #0a0a0a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 99999;
    gap: 1rem;
  `;

  const h1 = document.createElement('h1');
  h1.style.cssText = 'font-size: 1.875rem; color: #ef4444; font-weight: bold;';
  h1.textContent = 'ğŸš« ACCESS DENIED';

  const p = document.createElement('p');
  p.style.cssText = 'color: #888; font-size: 0.875rem;';
  p.textContent = 'You have been banned from Konvo.';

  const p2 = document.createElement('p');
  p2.style.cssText = 'color: #555; font-size: 0.75rem; margin-top: 1rem;';
  p2.textContent = 'If you believe this is a mistake, please wait for admin review.';

  overlay.appendChild(h1);
  overlay.appendChild(p);
  overlay.appendChild(p2);
  document.body.appendChild(overlay);
}

/**
 * Show unbanned screen
 */
function showUnbannedScreen() {
  const banOverlay = document.getElementById('banOverlayScreen');
  if (banOverlay) banOverlay.remove();

  const overlay = document.createElement('div');
  overlay.id = 'unbanOverlayScreen';
  overlay.style.cssText = `
    position: fixed;
    inset: 0;
    background-color: #0a0a0a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 99999;
    gap: 1rem;
  `;

  const h1 = document.createElement('h1');
  h1.style.cssText = 'font-size: 1.875rem; color: #22c55e; font-weight: bold;';
  h1.textContent = 'âœ… ACCESS RESTORED';

  const p = document.createElement('p');
  p.style.cssText = 'color: #888; font-size: 0.875rem; text-align: center; max-width: 300px;';
  p.textContent = 'Your ban has been lifted. Click below to continue using Konvo.';

  const btn = document.createElement('button');
  btn.style.cssText = `
    margin-top: 1.5rem;
    padding: 0.75rem 2rem;
    background-color: #22c55e;
    color: #000;
    border: none;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1rem;
    cursor: pointer;
  `;
  btn.textContent = 'CONTINUE';
  btn.onclick = () => window.location.reload();

  overlay.appendChild(h1);
  overlay.appendChild(p);
  overlay.appendChild(btn);
  document.body.appendChild(overlay);
}

/**
 * Check if fully unbanned
 */
async function checkFullUnbanStatus() {
  if (!state.db || !state.deviceInfo) return;

  try {
    const banResult = await checkAllBans(state.db, state.currentUserId, state.deviceInfo);

    if (!banResult.isBanned) {
      state.isBanned = false;
      state.isDeviceBanned = false;
      showUnbannedScreen();
    }
  } catch (error) {
    console.error('Error checking unban status:', error);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SVG ICON CREATORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function createEnabledBellIcon() {
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns, "svg");
  svg.setAttribute("width", "18");
  svg.setAttribute("height", "18");
  svg.setAttribute("viewBox", "0 0 24 24");
  svg.setAttribute("fill", "currentColor");
  svg.setAttribute("stroke", "currentColor");
  svg.setAttribute("stroke-width", "2");
  svg.setAttribute("aria-hidden", "true");

  const path1 = document.createElementNS(ns, "path");
  path1.setAttribute("d", "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9");

  const path2 = document.createElementNS(ns, "path");
  path2.setAttribute("d", "M13.73 21a2 2 0 0 1-3.46 0");

  svg.appendChild(path1);
  svg.appendChild(path2);

  return svg;
}

function createDisabledBellIcon() {
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns, "svg");
  svg.setAttribute("width", "18");
  svg.setAttribute("height", "18");
  svg.setAttribute("viewBox", "0 0 24 24");
  svg.setAttribute("fill", "none");
  svg.setAttribute("stroke", "currentColor");
  svg.setAttribute("stroke-width", "2");
  svg.setAttribute("aria-hidden", "true");

  const paths = [
    "M13.73 21a2 2 0 0 1-3 0",
    "M18.63 13A17.89 17.89 0 0 1 18 8",
    "M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14",
    "M18 8a6 6 0 0 0-9.33-5"
  ];

  paths.forEach(d => {
    const path = document.createElementNS(ns, "path");
    path.setAttribute("d", d);
    svg.appendChild(path);
  });

  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", "1");
  line.setAttribute("y1", "1");
  line.setAttribute("x2", "23");
  line.setAttribute("y2", "23");
  svg.appendChild(line);

  return svg;
}

function createKebabIcon() {
  const ns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(ns, "svg");
  svg.setAttribute("width", "14");
  svg.setAttribute("height", "14");
  svg.setAttribute("fill", "currentColor");
  svg.setAttribute("viewBox", "0 0 16 16");
  svg.setAttribute("aria-hidden", "true");

  const path = document.createElementNS(ns, "path");
  path.setAttribute("d", "M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z");
  svg.appendChild(path);

  return svg;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHARACTER COUNTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateCharacterCounter(input, counter) {
  if (!input || !counter) return;

  const currentLength = input.value.length;
  const maxLength = CONFIG.MESSAGE_MAX_LENGTH;

  counter.textContent = `${currentLength}/${maxLength}`;

  if (currentLength > 0) {
    counter.classList.add('visible');
  } else {
    counter.classList.remove('visible');
  }

  counter.classList.remove('warning', 'danger', 'limit');

  if (currentLength >= maxLength) {
    counter.classList.add('limit');
  } else if (currentLength >= maxLength * 0.95) {
    counter.classList.add('danger');
  } else if (currentLength >= maxLength * 0.8) {
    counter.classList.add('warning');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLIENT-SIDE RATE LIMITING (Additional Layer)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Check if can send message (client-side)
 */
function canSendMessageClientSide() {
  const now = Date.now();
  const timeSinceLastMessage = now - state.lastMessageTime;

  if (timeSinceLastMessage < CONFIG.MESSAGE_COOLDOWN_MS) {
    const waitTime = Math.ceil((CONFIG.MESSAGE_COOLDOWN_MS - timeSinceLastMessage) / 1000);
    return {
      allowed: false,
      message: `Please wait ${waitTime} second${waitTime > 1 ? 's' : ''} before sending another message.`
    };
  }

  return { allowed: true };
}

/**
 * Check if can react (client-side)
 */
function canReactClientSide() {
  const now = Date.now();
  return (now - state.lastReactionTime) >= CONFIG.REACTION_COOLDOWN_MS;
}

/**
 * Record message sent
 */
function recordMessageSent() {
  state.lastMessageTime = Date.now();
}

/**
 * Record reaction sent
 */
function recordReactionSent() {
  state.lastReactionTime = Date.now();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SERVICE WORKER & CONNECTION MONITORING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js', { scope: '/' })
      .then(reg => {
        reg.addEventListener('updatefound', () => {
          const newWorker = reg.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                showToast("New version available. Refresh to update.", "info");
              }
            });
          }
        });
      })
      .catch(err => {
        console.error('SW registration failed:', err);
      });
  }
}

function setupConnectionMonitor() {
  window.addEventListener('online', () => {
    showToast("You're back online!", "info");
    if (state.isInitialized) {
      showPage(state.currentPage);
    }
  });

  window.addEventListener('offline', () => {
    showToast("You're offline. Messages will sync when connected.", "warning");
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTIFICATION HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function setupNotificationButton() {
  if (!notificationButton) return;

  notificationButton.addEventListener("click", handleNotificationClick);

  if ("Notification" in window && Notification.permission === "granted") {
    state.notificationsEnabled = true;
  }

  updateNotificationIcon();
}

async function handleNotificationClick(e) {
  e.preventDefault();
  e.stopPropagation();

  if (!("Notification" in window)) {
    showToast("Notifications not supported in this browser", "error");
    return;
  }

  if (Notification.permission === "granted") {
    state.notificationsEnabled = !state.notificationsEnabled;
    updateNotificationIcon();
    showToast(
      state.notificationsEnabled ? "Notifications enabled" : "Notifications disabled",
      "info"
    );
  } else if (Notification.permission !== "denied") {
    try {
      const permission = await Notification.requestPermission();
      if (permission === "granted") {
        state.notificationsEnabled = true;
        updateNotificationIcon();
        showToast("Notifications enabled", "info");
      }
    } catch (err) {
      console.error('Notification permission error:', err);
    }
  } else {
    showToast("Notifications are blocked. Please enable in browser settings.", "error");
  }
}

function updateNotificationIcon() {
  if (!notificationButton) return;

  notificationButton.innerHTML = '';

  if (state.notificationsEnabled) {
    notificationButton.classList.add("text-yellow-400");
    notificationButton.appendChild(createEnabledBellIcon());
    notificationButton.title = "Notifications enabled - Click to disable";
  } else {
    notificationButton.classList.remove("text-yellow-400");
    notificationButton.appendChild(createDisabledBellIcon());
    notificationButton.title = "Notifications disabled - Click to enable";
  }
}

async function showNotification(title, body) {
  if (!("Notification" in window) || !state.notificationsEnabled) return;
  if (document.visibilityState === 'visible') return;

  const safeTitle = typeof title === 'string' ? title.substring(0, 50) : 'New Message';
  const safeBody = typeof body === 'string' ? body.substring(0, 100) : '';

  try {
    if ('serviceWorker' in navigator) {
      const reg = await navigator.serviceWorker.ready;
      if (reg) {
        await reg.showNotification(safeTitle, {
          body: safeBody,
          icon: "icon.jpg",
          badge: "icon.jpg",
          tag: 'konvo-message',
          renotify: true,
          requireInteraction: false
        });
        return;
      }
    }
    new Notification(safeTitle, { body: safeBody, icon: "icon.jpg" });
  } catch (e) {
    console.error('Notification error:', e);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLEANUP FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function cleanupAllListeners() {
  Object.entries(unsubscribers).forEach(([key, unsub]) => {
    if (typeof unsub === 'function') {
      try {
        unsub();
        unsubscribers[key] = null;
      } catch (e) {
        console.error(`Failed to unsubscribe ${key}:`, e);
      }
    }
  });
}

function cleanupNonBanListeners() {
  const banListenerKeys = ['banCheck', 'deviceBanCheck'];

  Object.entries(unsubscribers).forEach(([key, unsub]) => {
    if (banListenerKeys.includes(key)) return;

    if (typeof unsub === 'function') {
      try {
        unsub();
        unsubscribers[key] = null;
      } catch (e) {
        console.error(`Failed to unsubscribe ${key}:`, e);
      }
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADMIN MENU SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function setupAdminMenu() {
  const ul = contextMenu?.querySelector("ul");
  if (!ul || document.getElementById("menuPin")) return;

  menuPin = document.createElement("li");
  menuPin.id = "menuPin";
  menuPin.setAttribute("role", "menuitem");
  menuPin.setAttribute("tabindex", "-1");
  menuPin.textContent = "Pin Message ğŸ“Œ";
  menuPin.addEventListener("click", togglePinMessage);

  if (menuDelete) {
    ul.insertBefore(menuPin, menuDelete);
  }

  menuBan = document.createElement("li");
  menuBan.id = "menuBan";
  menuBan.className = "text-red-500 hover:text-red-400 font-bold border-t border-[#333] mt-1 pt-1";
  menuBan.setAttribute("role", "menuitem");
  menuBan.setAttribute("tabindex", "-1");
  menuBan.textContent = "Ban User ğŸš«";
  menuBan.addEventListener("click", toggleBanUser);

  ul.appendChild(menuBan);
}

async function togglePinMessage() {
  if (!state.currentContextMenuData || !state.db) return;

  const { id, isPinned, text } = state.currentContextMenuData;
  const isCurrentlyPinned = isPinned === "true";

  hideDropdownMenu();

  try {
    const batch = writeBatch(state.db);

    const msgRef = doc(state.db, state.currentPage, id);
    batch.update(msgRef, { isPinned: !isCurrentlyPinned });

    const pinRef = doc(state.db, "pinned_messages", id);

    if (isCurrentlyPinned) {
      batch.delete(pinRef);
    } else {
      batch.set(pinRef, {
        originalId: id,
        collection: state.currentPage,
        text: text?.substring(0, 200) || '',
        pinnedBy: state.currentUserId,
        timestamp: serverTimestamp()
      });
    }

    await batch.commit();
    showToast(isCurrentlyPinned ? "Message unpinned" : "Message pinned", "info");
  } catch (e) {
    console.error('Pin error:', e);
    showToast("Failed to pin message. Check Admin permissions.", "error");
  }
}

async function toggleBanUser() {
  if (!state.currentContextMenuData || !state.db) return;

  const { userId, username } = state.currentContextMenuData;

  if (userId === state.currentUserId) {
    showToast("You cannot ban yourself.", "error");
    hideDropdownMenu();
    return;
  }

  hideDropdownMenu();

  let isBanned = false;
  try {
    const banDocRef = doc(state.db, "banned_users", userId);
    const banDocSnap = await getDoc(banDocRef);
    isBanned = banDocSnap.exists();
  } catch (e) {
    showToast("Error checking ban status. Please try again.", "error");
    return;
  }

  const action = isBanned ? "UNBAN" : "BAN";
  const safeUsername = sanitizeText(username || 'this user');

  const confirmMessage = isBanned
    ? `Unban ${safeUsername}? This will restore their access including their device and IP.`
    : `Ban ${safeUsername}? This will also ban their device fingerprint and IP address.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  try {
    const batch = writeBatch(state.db);

    const userRef = doc(state.db, "users", userId);
    if (isBanned) {
      batch.update(userRef, { banned: false });
    } else {
      batch.set(userRef, { banned: true }, { merge: true });
    }

    const banRef = doc(state.db, "banned_users", userId);
    if (isBanned) {
      batch.delete(banRef);
    } else {
      batch.set(banRef, {
        bannedBy: state.currentUserId,
        timestamp: serverTimestamp(),
        reason: "Admin Action",
        username: username?.substring(0, 30) || 'Unknown'
      });
    }

    // Get user's devices for device/IP bans
    const devicesQuery = query(
      collection(state.db, "user_devices"),
      where("userId", "==", userId)
    );

    let devicesSnapshot;
    try {
      devicesSnapshot = await getDocs(devicesQuery);
    } catch (e) {
      devicesSnapshot = { docs: [] };
    }

    const processedFingerprints = new Set();
    const processedIPs = new Set();

    for (const deviceDoc of devicesSnapshot.docs) {
      const deviceData = deviceDoc.data();

      if (deviceData.fingerprint && !processedFingerprints.has(deviceData.fingerprint)) {
        processedFingerprints.add(deviceData.fingerprint);

        const fingerprintBanRef = doc(state.db, "banned_devices", deviceData.fingerprint);

        if (isBanned) {
          batch.delete(fingerprintBanRef);
        } else {
          batch.set(fingerprintBanRef, {
            fingerprint: deviceData.fingerprint,
            userId: userId,
            username: username?.substring(0, 30) || 'Unknown',
            bannedBy: state.currentUserId,
            timestamp: serverTimestamp(),
            reason: "Admin Action",
            userAgent: deviceData.userAgent || null,
            platform: deviceData.platform || null,
          });
        }
      }

      if (deviceData.ipHash && !processedIPs.has(deviceData.ipHash)) {
        processedIPs.add(deviceData.ipHash);
        const ipBanRef = doc(state.db, "banned_ips", deviceData.ipHash);

        if (isBanned) {
          batch.delete(ipBanRef);
        } else {
          batch.set(ipBanRef, {
            ipHash: deviceData.ipHash,
            fingerprint: deviceData.fingerprint || null,
            userId: userId,
            username: username?.substring(0, 30) || 'Unknown',
            bannedBy: state.currentUserId,
            timestamp: serverTimestamp(),
            reason: "Admin Action",
          });
        }
      }
    }

    await batch.commit();

    if (state.userProfiles[userId]) {
      state.userProfiles[userId].banned = !isBanned;
    }

    const devicesCount = processedFingerprints.size;
    const ipsCount = processedIPs.size;

    showToast(
      isBanned
        ? `User unbanned. Removed ${devicesCount} device ban(s) and ${ipsCount} IP ban(s).`
        : `User banned. Added ${devicesCount} device ban(s) and ${ipsCount} IP ban(s).`,
      "info"
    );

  } catch (e) {
    console.error('Ban error:', e);
    showToast(`Failed to ${action.toLowerCase()} user: ${e.message}`, "error");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIREBASE INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function initFirebase() {
  const globalTimeout = setTimeout(() => {
    hideBanCheckOverlay();
  }, 15000);

  try {
    // Step 1: Initialize device identification
    state.deviceInfo = await initializeDeviceIdentification();

    // Step 2: Initialize Firebase
    state.app = initializeApp(firebaseConfig);

    // Initialize Firestore with persistence
    try {
      state.db = initializeFirestore(state.app, {
        localCache: persistentLocalCache({
          tabManager: persistentMultipleTabManager()
        })
      });
    } catch (persistenceError) {
      console.warn('Firestore persistence failed, using default:', persistenceError);
      state.db = initializeFirestore(state.app, {});
    }

    state.auth = getAuth(state.app);
    state.functions = getFunctions(state.app);

    // Initialize Cloud Functions references
    state.sendMessageFn = httpsCallable(state.functions, 'sendMessage');
    state.setUsernameFn = httpsCallable(state.functions, 'setUsername');

    // Optional: Initialize App Check
    // const appCheck = initializeAppCheck(state.app, {
    //   provider: new ReCaptchaV3Provider('YOUR_RECAPTCHA_SITE_KEY'),
    //   isTokenAutoRefreshEnabled: true
    // });

    onAuthStateChanged(state.auth, async (user) => {
      try {
        await handleAuthStateChange(user);
      } catch (error) {
        console.error('Auth state change error:', error);
        hideBanCheckOverlay();
      } finally {
        clearTimeout(globalTimeout);
      }
    });

  } catch (error) {
    console.error('Firebase init error:', error);
    setTextSafely(loading, "Error: Could not initialize. Please refresh.");
    hideBanCheckOverlay();
    clearTimeout(globalTimeout);
    throw error;
  }
}

async function handleAuthStateChange(user) {
  if (user) {
    state.currentUserId = user.uid;

    // Check all bans BEFORE proceeding
    try {
      const banResult = await withTimeout(
        checkAllBans(state.db, state.currentUserId, state.deviceInfo),
        5000,
        { isBanned: false }
      );

      if (banResult.isBanned) {
        state.isBanned = banResult.banType === 'user';
        state.isDeviceBanned = banResult.banType === 'device' || banResult.banType === 'ip';

        if (state.isDeviceBanned) {
          showDeviceBannedScreen(banResult.reason);
        } else {
          showBannedScreen();
        }
        return;
      }
    } catch (banCheckError) {
      console.error('Ban check error:', banCheckError);
    }

    // Register device (this will also fail if IP is banned)
    try {
      await registerDevice(state.db, state.currentUserId, state.deviceInfo);
    } catch (regError) {
      if (regError.code === 'permission-denied') {
        state.isDeviceBanned = true;
        showDeviceBannedScreen('Device or IP is banned');
        return;
      }
    }

    // Initialize collections
    state.confessionsCollection = collection(state.db, "confessions");
    state.chatCollection = collection(state.db, "chat");
    state.typingStatusCollection = collection(state.db, "typingStatus");

    // Setup app
    registerServiceWorker();
    setupNotificationButton();
    setupAdminMenu();
    setupConnectionMonitor();
    listenForUserProfiles();
    listenForBanStatus();
    listenForDeviceBans();

    try {
      await checkAdminStatus();
    } catch (e) {
      console.error('Admin check error:', e);
    }

    try {
      await loadUserProfile();
    } catch (e) {
      console.error('Profile load error:', e);
    }

    hideBanCheckOverlay();
    initScrollObserver();
    showPage(state.currentPage);

    state.isInitialized = true;

  } else {
    try {
      await signInAnonymously(state.auth);
    } catch (e) {
      console.error('Sign in error:', e);
      setTextSafely(loading, "Error: Could not sign in. Please refresh.");
      hideBanCheckOverlay();
    }
  }
}

async function checkAdminStatus() {
  if (!state.currentUserId || !state.db) return;

  try {
    const adminDocRef = doc(state.db, "admins", state.currentUserId);
    const adminDocSnap = await getDoc(adminDocRef);
    state.isCurrentUserAdmin = adminDocSnap.exists();
  } catch (e) {
    state.isCurrentUserAdmin = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REALTIME LISTENERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function listenForPinnedMessages() {
  if (typeof unsubscribers.pinned === 'function') {
    unsubscribers.pinned();
    unsubscribers.pinned = null;
  }

  const q = query(
    collection(state.db, "pinned_messages"),
    orderBy("timestamp", "desc")
  );

  unsubscribers.pinned = onSnapshot(q, (snapshot) => {
    const matchingPin = snapshot.docs.find(doc =>
      doc.data().collection === state.currentPage
    );

    if (matchingPin && pinnedMessageBar && pinnedMessageText) {
      const data = matchingPin.data();
      pinnedMessageBar.classList.remove("hidden");
      pinnedMessageBar.style.display = "flex";
      setTextSafely(pinnedMessageText, data.text);

      pinnedMessageBar.onclick = () => {
        const escapedId = escapeSelector(data.originalId);
        const bubble = document.querySelector(`.message-bubble[data-id="${escapedId}"]`);
        if (bubble) {
          bubble.scrollIntoView({ behavior: "smooth", block: "center" });
          bubble.classList.add("ring-2", "ring-yellow-400");
          setTimeout(() => {
            bubble.classList.remove("ring-2", "ring-yellow-400");
          }, 2000);
        }
      };
    } else if (pinnedMessageBar) {
      pinnedMessageBar.classList.add("hidden");
      pinnedMessageBar.style.display = "none";
    }
  }, (error) => {
    console.error('Pinned messages listener error:', error);
    if (pinnedMessageBar) {
      pinnedMessageBar.classList.add("hidden");
    }
  });
}

function listenForBanStatus() {
  if (typeof unsubscribers.banCheck === 'function') {
    unsubscribers.banCheck();
    unsubscribers.banCheck = null;
  }

  if (!state.currentUserId || !state.db) return;

  unsubscribers.banCheck = onSnapshot(
    doc(state.db, "banned_users", state.currentUserId),
    (docSnap) => {
      if (docSnap.exists()) {
        if (!state.isBanned) {
          state.isBanned = true;
          state.userProfiles = {};
          cleanupNonBanListeners();
          showBannedScreen();
        }
      } else {
        if (state.isBanned) {
          state.isBanned = false;
          showUnbannedScreen();
        }
      }
    },
    (error) => {
      console.error('Ban check error:', error);
    }
  );
}

function listenForDeviceBans() {
  if (typeof unsubscribers.deviceBanCheck === 'function') {
    unsubscribers.deviceBanCheck();
    unsubscribers.deviceBanCheck = null;
  }

  if (!state.db || !state.deviceInfo?.fingerprint) return;

  unsubscribers.deviceBanCheck = onSnapshot(
    doc(state.db, "banned_devices", state.deviceInfo.fingerprint),
    (docSnap) => {
      if (docSnap.exists()) {
        if (!state.isDeviceBanned) {
          state.isDeviceBanned = true;
          cleanupNonBanListeners();
          showDeviceBannedScreen('Device fingerprint banned');
        }
      } else {
        if (state.isDeviceBanned) {
          checkFullUnbanStatus();
        }
      }
    },
    (error) => {
      console.error('Device ban check error:', error);
    }
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCROLL HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function initScrollObserver() {
  const options = {
    root: feedContainer,
    rootMargin: "100px",
    threshold: 0.1
  };

  state.bottomObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      state.userIsAtBottom = entry.isIntersecting;
      updateScrollButton();
    });
  }, options);

  // Infinite scroll for loading more messages
  feedContainer?.addEventListener('scroll', throttle(() => {
    if (feedContainer.scrollTop < CONFIG.SCROLL_THRESHOLD &&
      state.hasMoreMessages &&
      !state.isLoadingMore) {
      loadMoreMessages();
    }
  }, 200), { passive: true });
}

function updateScrollButton() {
  if (!scrollToBottomBtn || !newMsgCount) return;

  if (state.userIsAtBottom) {
    scrollToBottomBtn.classList.add("hidden");
    scrollToBottomBtn.style.display = "";
    newMsgCount.classList.add("hidden");
    state.unreadMessages = 0;
  } else {
    scrollToBottomBtn.classList.remove("hidden");
    scrollToBottomBtn.style.display = "flex";

    if (state.unreadMessages > 0) {
      newMsgCount.classList.remove("hidden");
      setTextSafely(newMsgCount,
        state.unreadMessages > 99 ? "99+" : String(state.unreadMessages)
      );
    } else {
      newMsgCount.classList.add("hidden");
    }
  }
}

function scrollToBottom() {
  if (!feedContainer) return;
  feedContainer.scrollTop = feedContainer.scrollHeight;
  state.userIsAtBottom = true;
  state.unreadMessages = 0;
  updateScrollButton();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USER PROFILE MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function requestUserProfile(userId) {
  if (!userId || typeof userId !== 'string') return;
  if (state.userProfiles[userId]) return;
  if (state.pendingProfileLoads.has(userId)) return;

  state.pendingProfileLoads.add(userId);

  if (state.profileLoadTimeout) {
    clearTimeout(state.profileLoadTimeout);
  }

  state.profileLoadTimeout = setTimeout(() => {
    loadPendingProfiles();
  }, 100);
}

async function loadPendingProfiles() {
  if (state.pendingProfileLoads.size === 0) return;
  if (!state.db) return;

  const userIds = Array.from(state.pendingProfileLoads);
  state.pendingProfileLoads.clear();

  for (let i = 0; i < userIds.length; i += CONFIG.PROFILE_BATCH_SIZE) {
    const batch = userIds.slice(i, i + CONFIG.PROFILE_BATCH_SIZE);

    try {
      const q = query(
        collection(state.db, "users"),
        where("__name__", "in", batch)
      );

      const snapshot = await getDocs(q);

      snapshot.docs.forEach((docSnap) => {
        state.userProfiles[docSnap.id] = docSnap.data();
      });
    } catch (error) {
      console.error('Batch profile load error:', error);
      // Fall back to individual loads
      for (const userId of batch) {
        try {
          const docRef = doc(state.db, "users", userId);
          const docSnap = await getDoc(docRef);
          if (docSnap.exists()) {
            state.userProfiles[docSnap.id] = docSnap.data();
          }
        } catch (e) {
          console.error('Individual profile load error:', e);
        }
      }
    }
  }

  updateDisplayedUsernames();
}

function updateDisplayedUsernames() {
  document.querySelectorAll('.message-bubble').forEach((bubble) => {
    const userId = bubble.dataset.userId;
    if (!userId) return;

    const profile = state.userProfiles[userId];
    if (!profile) return;

    const username = profile.username || "Anonymous";

    const usernameEl = bubble.querySelector('.font-bold.text-sm.opacity-90');
    if (usernameEl && usernameEl.textContent !== username) {
      usernameEl.textContent = username;
    }

    const imgEl = bubble.querySelector('.chat-pfp');
    if (imgEl && profile.profilePhotoURL) {
      const currentSrc = imgEl.getAttribute('src');
      if (currentSrc !== profile.profilePhotoURL && isValidProfilePhotoURL(profile.profilePhotoURL)) {
        imgEl.src = profile.profilePhotoURL;
      }
    }
  });
}

function listenForUserProfiles() {
  if (typeof unsubscribers.userProfiles === 'function') {
    unsubscribers.userProfiles();
    unsubscribers.userProfiles = null;
  }

  const checkAndSetupListener = () => {
    const loadedUserIds = Object.keys(state.userProfiles);

    if (loadedUserIds.length === 0) {
      setTimeout(checkAndSetupListener, 2000);
      return;
    }

    const userIdsToWatch = loadedUserIds.slice(0, 30);

    try {
      const q = query(
        collection(state.db, "users"),
        where("__name__", "in", userIdsToWatch)
      );

      unsubscribers.userProfiles = onSnapshot(q,
        (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            if (change.type === 'modified' || change.type === 'added') {
              state.userProfiles[change.doc.id] = change.doc.data();
            }
          });
          updateDisplayedUsernames();
        },
        (error) => {
          console.error('User profiles listener error:', error);
        }
      );
    } catch (e) {
      console.error('Error setting up profile listener:', e);
    }
  };

  setTimeout(checkAndSetupListener, 1000);
}

async function loadUserProfile() {
  if (!state.db || !state.currentUserId) return;

  try {
    const userDoc = await getDoc(doc(state.db, "users", state.currentUserId));

    if (userDoc.exists()) {
      const data = userDoc.data();
      state.userProfiles[state.currentUserId] = data;

      if (data.banned) {
        showBannedScreen();
        throw new Error("User Banned");
      }

      state.currentUsername = data.username || "Anonymous";

      const pfp = data.profilePhotoURL;
      if (pfp && isValidProfilePhotoURL(pfp)) {
        state.currentProfilePhotoURL = pfp;
      } else {
        state.currentProfilePhotoURL = null;
      }
    }

    if (modalUsernameInput) {
      modalUsernameInput.value = state.currentUsername === "Anonymous"
        ? ""
        : state.currentUsername;
    }
  } catch (error) {
    throw error;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROFILE MODAL HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleProfileSave() {
  if (!state.db || !state.currentUserId) {
    showToast("Not connected. Please refresh the page.", "error");
    return;
  }

  const inputVal = modalUsernameInput?.value?.trim();

  if (!inputVal) {
    showToast("Please enter a username.", "error");
    return;
  }

  if (!isValidUsername(inputVal)) {
    showToast("Invalid username. Use letters, numbers, underscores, hyphens, and spaces only (1-30 characters).", "error");
    if (modalUsernameInput) {
      modalUsernameInput.classList.add("error");
      setTimeout(() => modalUsernameInput.classList.remove("error"), 500);
    }
    return;
  }

  const resetButtonState = () => {
    if (modalSaveButton) {
      modalSaveButton.textContent = "Save";
      modalSaveButton.disabled = false;
      modalSaveButton.classList.remove("loading");
    }
    if (modalCloseButton) {
      modalCloseButton.disabled = false;
    }
    if (modalUsernameInput) {
      modalUsernameInput.disabled = false;
    }
  };

  // Disable inputs
  if (modalSaveButton) {
    modalSaveButton.textContent = "SAVING...";
    modalSaveButton.disabled = true;
    modalSaveButton.classList.add("loading");
  }
  if (modalCloseButton) {
    modalCloseButton.disabled = true;
  }
  if (modalUsernameInput) {
    modalUsernameInput.disabled = true;
  }

  try {
    // Use Cloud Function for atomic username setting
    if (state.setUsernameFn) {
      await state.setUsernameFn({ username: inputVal });
    } else {
      // Fallback to direct write if Cloud Function not available
      const newProfilePhotoURL = `https://ui-avatars.com/api/?name=${encodeURIComponent(inputVal)}&background=random&size=128`;

      const userDocRef = doc(state.db, "users", state.currentUserId);
      const existingDoc = await getDoc(userDocRef);

      if (existingDoc.exists()) {
        await setDoc(userDocRef, {
          username: inputVal,
          profilePhotoURL: newProfilePhotoURL,
          lastMessageAt: serverTimestamp(),
        }, { merge: true });
      } else {
        await setDoc(userDocRef, {
          username: inputVal,
          profilePhotoURL: newProfilePhotoURL,
          trustLevel: 0,
          messageCount: 0,
          createdAt: serverTimestamp(),
          lastMessageAt: serverTimestamp(),
        });
      }
    }

    // Update local state
    const newProfilePhotoURL = `https://ui-avatars.com/api/?name=${encodeURIComponent(inputVal)}&background=random&size=128`;
    state.currentUsername = inputVal;
    state.currentProfilePhotoURL = newProfilePhotoURL;

    state.userProfiles[state.currentUserId] = {
      ...state.userProfiles[state.currentUserId],
      username: inputVal,
      profilePhotoURL: newProfilePhotoURL
    };

    showToast("Profile saved successfully!", "info");
    closeProfileModal();
    resetButtonState();

  } catch (error) {
    console.error('Profile save error:', error);

    if (error.code === 'functions/already-exists') {
      showToast("Username is already taken!", "error");
    } else if (error.code === 'permission-denied' || error.code === 'functions/permission-denied') {
      showToast("Permission denied. You may be banned.", "error");
    } else if (error.code === 'unavailable' || error.code === 'functions/unavailable') {
      showToast("Server unavailable. Please try again.", "error");
    } else {
      showToast("Error saving profile: " + (error.message || "Unknown error"), "error");
    }

    resetButtonState();
  }
}

function openProfileModal() {
  if (!modalUsernameInput || !profileModal) return;

  modalUsernameInput.value = state.currentUsername === "Anonymous"
    ? ""
    : state.currentUsername;

  profileModal.classList.add("is-open");
  profileModal.setAttribute("aria-hidden", "false");

  setTimeout(() => modalUsernameInput.focus(), 100);
}

function closeProfileModal() {
  if (!profileModal) return;

  profileModal.classList.remove("is-open");
  profileModal.setAttribute("aria-hidden", "true");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EDIT MODAL HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showEditModal(docId, collectionName, currentText) {
  if (!editModal || !modalEditTextArea) return;

  state.docToEditId = docId;
  state.collectionToEdit = collectionName;

  modalEditTextArea.value = currentText || '';

  editModal.classList.add("is-open");
  editModal.setAttribute("aria-hidden", "false");

  setTimeout(() => {
    modalEditTextArea.focus();
    modalEditTextArea.setSelectionRange(
      modalEditTextArea.value.length,
      modalEditTextArea.value.length
    );
  }, 100);
}

function closeEditModal() {
  if (!editModal) return;

  editModal.classList.remove("is-open");
  editModal.setAttribute("aria-hidden", "true");

  state.docToEditId = null;
  state.collectionToEdit = null;
}

async function saveEdit() {
  const newText = modalEditTextArea.value.trim();

  if (!isValidMessageText(newText)) {
    showToast(`Message must be 1-${CONFIG.MESSAGE_MAX_LENGTH} characters.`, "error");
    return;
  }

  if (!state.docToEditId || !state.db) return;

  editModalSaveButton.textContent = "SAVING...";
  editModalSaveButton.disabled = true;
  editModalCancelButton.disabled = true;
  editModalSaveButton.classList.add("loading");

  try {
    await updateDoc(doc(state.db, state.collectionToEdit, state.docToEditId), {
      text: newText,
      edited: true
    });

    showToast("Message updated", "info");
    closeEditModal();
  } catch (e) {
    console.error('Edit error:', e);
    showToast("Error: You can only edit your own messages.", "error");
  } finally {
    editModalSaveButton.textContent = "SAVE";
    editModalSaveButton.disabled = false;
    editModalCancelButton.disabled = false;
    editModalSaveButton.classList.remove("loading");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIRM MODAL HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showConfirmModal(text, isMine, docId) {
  if (!confirmModal || !confirmModalActionContainer) return;

  setTextSafely(confirmModalText, text);

  confirmModalActionContainer.innerHTML = '';

  const isAdmin = state.isCurrentUserAdmin;

  if (isMine || isAdmin) {
    const btnForMe = document.createElement('button');
    btnForMe.type = 'button';
    btnForMe.className = "flex-1 px-4 py-2 rounded-lg font-bold text-sm border border-white text-white hover:bg-white hover:text-black transition";
    btnForMe.textContent = "FOR ME";
    btnForMe.onclick = async () => {
      closeConfirmModal();
      try {
        await updateDoc(doc(state.db, state.currentPage, docId), {
          hiddenFor: arrayUnion(state.currentUserId)
        });
        showToast("Message hidden", "info");
      } catch (e) {
        console.error('Hide error:', e);
      }
    };

    const btnEveryone = document.createElement('button');
    btnEveryone.type = 'button';
    btnEveryone.className = "flex-1 px-4 py-2 rounded-lg font-bold text-sm bg-red-600 text-white hover:bg-red-500 border border-red-600 transition";
    btnEveryone.textContent = isAdmin && !isMine ? "NUKE (ADMIN)" : "EVERYONE";
    btnEveryone.onclick = async () => {
      closeConfirmModal();
      try {
        await deleteDoc(doc(state.db, state.currentPage, docId));
        showToast("Message deleted", "info");
      } catch (e) {
        console.error('Delete error:', e);
        showToast("Permission denied.", "error");
      }
    };

    confirmModalActionContainer.appendChild(btnForMe);
    confirmModalActionContainer.appendChild(btnEveryone);
  } else {
    const btnForMe = document.createElement('button');
    btnForMe.type = 'button';
    btnForMe.className = "flex-1 px-4 py-2 rounded-lg font-bold text-sm bg-red-600 text-white hover:bg-red-500 transition";
    btnForMe.textContent = "HIDE";
    btnForMe.onclick = async () => {
      closeConfirmModal();
      try {
        await updateDoc(doc(state.db, state.currentPage, docId), {
          hiddenFor: arrayUnion(state.currentUserId)
        });
        showToast("Message hidden", "info");
      } catch (e) {
        console.error('Hide error:', e);
      }
    };

    confirmModalActionContainer.appendChild(btnForMe);
  }

  confirmModal.classList.add("is-open");
  confirmModal.setAttribute("aria-hidden", "false");
}

function closeConfirmModal() {
  if (!confirmModal) return;

  confirmModal.classList.remove("is-open");
  confirmModal.setAttribute("aria-hidden", "true");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REACTIONS HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function toggleReaction(docId, collectionName, reactionType, hasReacted) {
  if (!state.db || !state.currentUserId) return;

  if (!Object.prototype.hasOwnProperty.call(REACTION_TYPES, reactionType)) {
    return;
  }

  // Client-side rate limiting
  if (!canReactClientSide()) {
    return; // Silently ignore rapid clicks
  }

  const escapedId = escapeSelector(docId);
  const bubble = document.querySelector(`.message-bubble[data-id="${escapedId}"]`);

  // Optimistic UI update
  if (bubble) {
    updateReactionUI(bubble, reactionType, !hasReacted, collectionName);
  }

  recordReactionSent();

  try {
    const batch = writeBatch(state.db);

    const docRef = doc(state.db, collectionName, docId);
    if (hasReacted) {
      batch.update(docRef, {
        [`reactions.${reactionType}`]: arrayRemove(state.currentUserId)
      });
    } else {
      batch.update(docRef, {
        [`reactions.${reactionType}`]: arrayUnion(state.currentUserId)
      });
    }

    // Update user's lastReactionAt for server-side rate limiting
    const userRef = doc(state.db, "users", state.currentUserId);
    batch.update(userRef, {
      lastReactionAt: serverTimestamp()
    });

    await batch.commit();
  } catch (error) {
    console.error('Reaction error:', error);

    // Revert UI on failure
    if (bubble) {
      updateReactionUI(bubble, reactionType, hasReacted, collectionName);
    }

    if (error.code === 'permission-denied') {
      showToast("Unable to add reaction. Please wait.", "error");
    }
  }
}

function updateReactionUI(bubble, reactionType, isAdding, collectionName) {
  if (!bubble) return;

  let chipsContainer = bubble.querySelector('.reaction-chips-container');

  if (!chipsContainer) {
    chipsContainer = document.createElement('div');
    chipsContainer.className = 'reaction-chips-container';
    bubble.appendChild(chipsContainer);
  }

  let existingChip = null;
  chipsContainer.querySelectorAll('.reaction-chip').forEach(chip => {
    const emoji = chip.querySelector('span')?.textContent;
    if (emoji === REACTION_TYPES[reactionType]) {
      existingChip = chip;
    }
  });

  if (isAdding) {
    if (existingChip) {
      const countSpan = existingChip.querySelectorAll('span')[1];
      if (countSpan) {
        const currentCount = parseInt(countSpan.textContent.trim()) || 0;
        countSpan.textContent = ` ${currentCount + 1}`;
      }
      existingChip.classList.add('user-reacted');
    } else {
      const chip = document.createElement('div');
      chip.className = 'reaction-chip user-reacted';
      chip.style.animation = 'modalZoom 0.2s ease-out';

      const emojiSpan = document.createElement('span');
      emojiSpan.textContent = REACTION_TYPES[reactionType];

      const countSpan = document.createElement('span');
      countSpan.textContent = ' 1';

      chip.appendChild(emojiSpan);
      chip.appendChild(countSpan);

      chip.onclick = (e) => {
        e.stopPropagation();
        toggleReaction(bubble.dataset.id, collectionName, reactionType, true);
      };

      chipsContainer.appendChild(chip);
    }

    bubble.classList.add('has-reactions');
  } else {
    if (existingChip) {
      const countSpan = existingChip.querySelectorAll('span')[1];
      if (countSpan) {
        const currentCount = parseInt(countSpan.textContent.trim()) || 0;
        if (currentCount <= 1) {
          existingChip.remove();
          if (chipsContainer.children.length === 0) {
            chipsContainer.remove();
            bubble.classList.remove('has-reactions');
          }
        } else {
          countSpan.textContent = ` ${currentCount - 1}`;
          existingChip.classList.remove('user-reacted');
        }
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTEXT MENU HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showDropdownMenu(event, data) {
  event.stopPropagation();

  if (!contextMenu) {
    return;
  }

  if (contextMenu.classList.contains("is-open") &&
    state.currentContextMenuData?.id === data.id) {
    hideDropdownMenu();
    return;
  }

  state.currentContextMenuData = { ...data };

  const now = Date.now();
  const messageTime = parseInt(data.timestamp, 10);
  const isRecent = isNaN(messageTime) ? true : (now - messageTime < 900000);

  const isMine = data.isMine === "true";
  const isAdmin = state.isCurrentUserAdmin;

  if (menuEdit) {
    menuEdit.style.display = isRecent && isMine ? "block" : "none";
  }

  if (menuDelete) {
    menuDelete.style.display = "block";
  }

  if (menuPin) {
    menuPin.style.display = isAdmin ? "block" : "none";
    menuPin.textContent = data.isPinned === "true"
      ? "Unpin Message"
      : "Pin Message ğŸ“Œ";
  }

  if (menuBan) {
    menuBan.style.display = (isAdmin && !isMine) ? "block" : "none";

    if (isAdmin && !isMine && data.userId) {
      (async () => {
        try {
          const banDocRef = doc(state.db, "banned_users", data.userId);
          const banDocSnap = await getDoc(banDocRef);
          const isBanned = banDocSnap.exists();

          if (menuBan) {
            menuBan.textContent = isBanned ? "Unban User âœ…" : "Ban User ğŸš«";
            menuBan.className = isBanned
              ? "text-green-500 hover:text-green-400 font-bold border-t border-[#333] mt-1 pt-1"
              : "text-red-500 hover:text-red-400 font-bold border-t border-[#333] mt-1 pt-1";
          }
        } catch (e) {
          console.error('Ban status check error:', e);
        }
      })();
    }
  }

  const rect = event.currentTarget.getBoundingClientRect();
  const menuWidth = 150;

  let left = isMine ? rect.right - menuWidth : rect.left;

  if (left < 10) left = 10;
  if (left + menuWidth > window.innerWidth - 10) {
    left = window.innerWidth - menuWidth - 10;
  }

  contextMenu.style.top = `${rect.bottom + 2}px`;
  contextMenu.style.left = `${left}px`;

  contextMenu.classList.add("is-open");
}

function hideDropdownMenu() {
  if (contextMenu) {
    contextMenu.classList.remove("is-open");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELECTION MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function handleMessageClick(bubble) {
  if (!state.isSelectionMode) return;

  const docId = bubble.dataset.id;

  if (state.selectedMessages.has(docId)) {
    state.selectedMessages.delete(docId);
    bubble.classList.remove("selected-message");
  } else {
    state.selectedMessages.add(docId);
    bubble.classList.add("selected-message");
  }

  updateSelectionBar();
}

function enterSelectionMode() {
  state.isSelectionMode = true;
  document.body.classList.add("selection-mode");

  if (selectionBar) {
    selectionBar.classList.remove("hidden");
    selectionBar.style.display = "flex";
  }

  if (chatForm) chatForm.classList.add("hidden");
  if (confessionForm) confessionForm.classList.add("hidden");

  if (state.currentContextMenuData) {
    const docId = state.currentContextMenuData.id;
    state.selectedMessages.add(docId);

    const escapedId = escapeSelector(docId);
    const bubble = document.querySelector(`.message-bubble[data-id="${escapedId}"]`);
    if (bubble) {
      bubble.classList.add("selected-message");
    }
  }

  updateSelectionBar();
}

function exitSelectionMode() {
  state.isSelectionMode = false;
  document.body.classList.remove("selection-mode");

  if (selectionBar) {
    selectionBar.classList.add("hidden");
  }

  state.selectedMessages.clear();

  if (state.currentPage === "chat") {
    if (chatForm) {
      chatForm.classList.remove("hidden");
      chatForm.classList.add("flex");
      } else {
    if (confessionForm) {
      confessionForm.classList.remove("hidden");
      confessionForm.classList.add("flex");
    }
  }

  document.querySelectorAll(".selected-message").forEach(el => {
    el.classList.remove("selected-message");
  });
}

function updateSelectionBar() {
  const count = state.selectedMessages.size;
  setTextSafely(selectionCount, `${count} selected`);

  if (count === 0 && state.isSelectionMode) {
    exitSelectionMode();
  }
}

async function handleMultiDelete() {
  const count = state.selectedMessages.size;
  if (count === 0) return;

  let allMine = true;
  state.selectedMessages.forEach(id => {
    const escapedId = escapeSelector(id);
    const bubble = document.querySelector(`.message-bubble[data-id="${escapedId}"]`);
    if (bubble && bubble.dataset.isMine !== "true") {
      allMine = false;
    }
  });

  const isAdmin = state.isCurrentUserAdmin;
  const canDeleteEveryone = isAdmin || allMine;

  setTextSafely(confirmModalText, `Delete ${count} message${count > 1 ? 's' : ''}?`);

  if (confirmModalActionContainer) {
    confirmModalActionContainer.innerHTML = '';

    const btnForMe = document.createElement('button');
    btnForMe.type = 'button';
    btnForMe.className = "flex-1 px-4 py-2 rounded-lg font-bold text-sm border border-white text-white hover:bg-white hover:text-black transition";
    btnForMe.textContent = "FOR ME";
    btnForMe.onclick = async () => {
      closeConfirmModal();

      const batch = writeBatch(state.db);
      state.selectedMessages.forEach((docId) => {
        const docRef = doc(state.db, state.currentPage, docId);
        batch.update(docRef, { hiddenFor: arrayUnion(state.currentUserId) });
      });

      try {
        await batch.commit();
        showToast(`${count} message(s) hidden`, "info");
      } catch (e) {
        console.error('Hide error:', e);
        showToast("Failed to hide messages.", "error");
      }

      exitSelectionMode();
    };

    confirmModalActionContainer.appendChild(btnForMe);

    if (canDeleteEveryone) {
      const btnEveryone = document.createElement('button');
      btnEveryone.type = 'button';
      btnEveryone.className = "flex-1 px-4 py-2 rounded-lg font-bold text-sm bg-red-600 text-white hover:bg-red-500 border border-red-600 transition";
      btnEveryone.textContent = "EVERYONE";
      btnEveryone.onclick = async () => {
        closeConfirmModal();

        const batch = writeBatch(state.db);
        state.selectedMessages.forEach((docId) => {
          const docRef = doc(state.db, state.currentPage, docId);
          batch.delete(docRef);
        });

        try {
          await batch.commit();
          showToast(`${count} message(s) deleted`, "info");
        } catch (e) {
          console.error('Delete error:', e);
          showToast("Failed to delete messages.", "error");
        }

        exitSelectionMode();
      };

      confirmModalActionContainer.appendChild(btnEveryone);
    }
  }

  if (confirmModal) {
    confirmModal.classList.add("is-open");
    confirmModal.setAttribute("aria-hidden", "false");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAGE NAVIGATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showPage(page) {
  if (page !== 'chat' && page !== 'confessions') {
    page = 'chat';
  }

  state.currentPage = page;

  // Reset pagination state
  state.lastVisibleMessage = null;
  state.isLoadingMore = false;
  state.hasMoreMessages = true;

  if (state.isSelectionMode) exitSelectionMode();
  cancelReplyMode();

  // Close any open reaction pickers
  document.querySelectorAll(".reaction-picker").forEach(p => p.remove());

  // Cleanup listeners
  if (typeof unsubscribers.confessions === 'function') {
    unsubscribers.confessions();
    unsubscribers.confessions = null;
  }

  if (typeof unsubscribers.chat === 'function') {
    unsubscribers.chat();
    unsubscribers.chat = null;
  }

  if (typeof unsubscribers.typingStatus === 'function') {
    unsubscribers.typingStatus();
    unsubscribers.typingStatus = null;
  }

  if (typingIndicator) typingIndicator.innerHTML = "&nbsp;";

  state.unreadMessages = 0;
  if (newMsgCount) newMsgCount.classList.add("hidden");
  if (scrollToBottomBtn) {
    scrollToBottomBtn.classList.add("hidden");
    scrollToBottomBtn.style.display = "";
  }

  listenForPinnedMessages();

  if (page === "confessions") {
    navConfessions?.classList.add("active");
    navConfessions?.setAttribute("aria-pressed", "true");
    navChat?.classList.remove("active");
    navChat?.setAttribute("aria-pressed", "false");

    if (confessionForm) {
      confessionForm.classList.add("flex");
      confessionForm.classList.remove("hidden");
    }
    if (chatForm) {
      chatForm.classList.add("hidden");
      chatForm.classList.remove("flex");
    }

    if (typingIndicator) typingIndicator.classList.add("hidden");

    listenForConfessions();
  } else {
    navChat?.classList.add("active");
    navChat?.setAttribute("aria-pressed", "true");
    navConfessions?.classList.remove("active");
    navConfessions?.setAttribute("aria-pressed", "false");

    if (chatForm) {
      chatForm.classList.add("flex");
      chatForm.classList.remove("hidden");
    }
    if (confessionForm) {
      confessionForm.classList.add("hidden");
      confessionForm.classList.remove("flex");
    }

    if (typingIndicator) typingIndicator.classList.remove("hidden");

    listenForChat();
    listenForTyping();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FEED RENDERING WITH PAGINATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function safeRenderFeed(docs, type, snapshot, isRerender, isFirstSnapshot = false) {
  try {
    renderFeed(docs, type, snapshot, isRerender, isFirstSnapshot);
  } catch (error) {
    console.error('Render error:', error);
    if (feedContainer) {
      feedContainer.innerHTML = '';

      const errorDiv = document.createElement("div");
      errorDiv.className = "text-center p-4 text-red-500";
      errorDiv.textContent = "Error rendering messages. Please refresh.";

      const retryBtn = document.createElement("button");
      retryBtn.className = "mt-2 px-4 py-2 bg-white text-black rounded";
      retryBtn.textContent = "Retry";
      retryBtn.onclick = () => showPage(state.currentPage);

      feedContainer.appendChild(errorDiv);
      feedContainer.appendChild(retryBtn);
    }
  }
}

function listenForConfessions(isRerender = false) {
  if (isRerender) {
    safeRenderFeed(state.lastConfessionDocs, "confessions", null, true);
    return;
  }

  if (typeof unsubscribers.chat === 'function') {
    unsubscribers.chat();
    unsubscribers.chat = null;
  }

  if (feedContainer) {
    feedContainer.innerHTML = '';
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'loading';
    loadingDiv.className = 'text-center p-4 text-[#888888] text-sm';
    loadingDiv.textContent = 'LOADING CONFESSIONS...';
    feedContainer.appendChild(loadingDiv);
  }

  let isFirstSnapshot = true;

  // Query with limit for pagination
  const initialQuery = query(
    state.confessionsCollection,
    orderBy("timestamp", "desc"),
    limit(CONFIG.MESSAGES_PER_PAGE)
  );

  unsubscribers.confessions = onSnapshot(
    initialQuery,
    (snapshot) => {
      if (snapshot.docs.length > 0) {
        state.lastVisibleMessage = snapshot.docs[snapshot.docs.length - 1];
      }
      state.hasMoreMessages = snapshot.docs.length === CONFIG.MESSAGES_PER_PAGE;

      // Reverse for display (oldest first at top)
      state.lastConfessionDocs = [...snapshot.docs].reverse();
      safeRenderFeed(state.lastConfessionDocs, "confessions", snapshot, false, isFirstSnapshot);
      isFirstSnapshot = false;
    },
    (error) => {
      console.error('Confessions listener error:', error);
      if (feedContainer) {
        feedContainer.innerHTML = '';
        const errorDiv = document.createElement("div");
        errorDiv.className = "text-center p-4 text-red-500";
        errorDiv.textContent = "Error loading confessions: " + error.message;
        feedContainer.appendChild(errorDiv);
      }
    }
  );
}

function listenForChat(isRerender = false) {
  if (isRerender) {
    safeRenderFeed(state.lastChatDocs, "chat", null, true);
    return;
  }

  if (typeof unsubscribers.confessions === 'function') {
    unsubscribers.confessions();
    unsubscribers.confessions = null;
  }

  if (feedContainer) {
    feedContainer.innerHTML = '';
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'loading';
    loadingDiv.className = 'text-center p-4 text-[#888888] text-sm';
    loadingDiv.textContent = 'LOADING CHAT...';
    feedContainer.appendChild(loadingDiv);
  }

  let isFirstSnapshot = true;

  // Query with limit for pagination
  const initialQuery = query(
    state.chatCollection,
    orderBy("timestamp", "desc"),
    limit(CONFIG.MESSAGES_PER_PAGE)
  );

  unsubscribers.chat = onSnapshot(
    initialQuery,
    (snapshot) => {
      if (snapshot.docs.length > 0) {
        state.lastVisibleMessage = snapshot.docs[snapshot.docs.length - 1];
      }
      state.hasMoreMessages = snapshot.docs.length === CONFIG.MESSAGES_PER_PAGE;

      // Reverse for display (oldest first at top)
      state.lastChatDocs = [...snapshot.docs].reverse();
      safeRenderFeed(state.lastChatDocs, "chat", snapshot, false, isFirstSnapshot);
      isFirstSnapshot = false;
    },
    (error) => {
      console.error('Chat listener error:', error);
      if (feedContainer) {
        feedContainer.innerHTML = '';
        const errorDiv = document.createElement("div");
        errorDiv.className = "text-center p-4 text-red-500";
        errorDiv.textContent = "Error loading chat: " + error.message;
        feedContainer.appendChild(errorDiv);
      }
    }
  );
}

async function loadMoreMessages() {
  if (state.isLoadingMore || !state.hasMoreMessages || !state.lastVisibleMessage) return;

  state.isLoadingMore = true;

  // Show loading indicator at top
  const loadingIndicator = document.createElement('div');
  loadingIndicator.id = 'load-more-indicator';
  loadingIndicator.className = 'text-center p-2 text-[#888] text-xs';
  loadingIndicator.textContent = 'Loading more...';
  feedContainer?.insertBefore(loadingIndicator, feedContainer.firstChild);

  try {
    const collectionRef = state.currentPage === 'chat' 
      ? state.chatCollection 
      : state.confessionsCollection;

    const olderQuery = query(
      collectionRef,
      orderBy("timestamp", "desc"),
      startAfter(state.lastVisibleMessage),
      limit(CONFIG.MESSAGES_PER_PAGE)
    );

    const snapshot = await getDocs(olderQuery);

    // Remove loading indicator
    loadingIndicator.remove();

    if (snapshot.docs.length > 0) {
      state.lastVisibleMessage = snapshot.docs[snapshot.docs.length - 1];
      state.hasMoreMessages = snapshot.docs.length === CONFIG.MESSAGES_PER_PAGE;

      // Prepend older messages (reversed for correct order)
      const olderDocs = [...snapshot.docs].reverse();
      
      if (state.currentPage === 'chat') {
        state.lastChatDocs = [...olderDocs, ...state.lastChatDocs];
        
        // Limit total messages to prevent memory issues
        if (state.lastChatDocs.length > CONFIG.MAX_MESSAGES_LOADED) {
          state.lastChatDocs = state.lastChatDocs.slice(0, CONFIG.MAX_MESSAGES_LOADED);
        }
      } else {
        state.lastConfessionDocs = [...olderDocs, ...state.lastConfessionDocs];
        
        if (state.lastConfessionDocs.length > CONFIG.MAX_MESSAGES_LOADED) {
          state.lastConfessionDocs = state.lastConfessionDocs.slice(0, CONFIG.MAX_MESSAGES_LOADED);
        }
      }

      // Re-render with scroll position preserved
      const scrollHeight = feedContainer.scrollHeight;
      const docs = state.currentPage === 'chat' ? state.lastChatDocs : state.lastConfessionDocs;
      safeRenderFeed(docs, state.currentPage, null, true);
      feedContainer.scrollTop = feedContainer.scrollHeight - scrollHeight;
    } else {
      state.hasMoreMessages = false;
    }
  } catch (error) {
    console.error('Load more error:', error);
    loadingIndicator.remove();
    showToast("Failed to load more messages", "error");
  } finally {
    state.isLoadingMore = false;
  }
}

function listenForTyping() {
  if (typeof unsubscribers.typingStatus === 'function') {
    unsubscribers.typingStatus();
    unsubscribers.typingStatus = null;
  }

  unsubscribers.typingStatus = onSnapshot(
    state.typingStatusCollection,
    (snapshot) => {
      const now = Date.now();
      const typingUsers = [];

      snapshot.docs.forEach((docSnap) => {
        const data = docSnap.data();
        const oduserId = docSnap.id;

        if (oduserId === state.currentUserId) return;

        if (data.isTyping && data.timestamp) {
          const timeSinceTyping = now - data.timestamp;

          if (timeSinceTyping < CONFIG.TYPING_STALE_THRESHOLD) {
            const username = state.userProfiles[oduserId]?.username || "Someone";
            typingUsers.push(username);
          }
        }
      });

      if (typingIndicator) {
        if (typingUsers.length === 0) {
          typingIndicator.innerHTML = "&nbsp;";
        } else if (typingUsers.length === 1) {
          setTextSafely(typingIndicator, `${typingUsers[0]} is typing...`);
        } else if (typingUsers.length === 2) {
          setTextSafely(typingIndicator, `${typingUsers[0]} and ${typingUsers[1]} are typing...`);
        } else {
          setTextSafely(typingIndicator, `${typingUsers.length} people are typing...`);
        }
      }
    },
    (error) => {
      console.error('Typing listener error:', error);
      if (typingIndicator) {
        typingIndicator.innerHTML = "&nbsp;";
      }
    }
  );
}

const updateTypingStatus = debounce(async (isTyping) => {
  if (!state.db || !state.currentUserId) return;

  // Client-side rate limiting for typing
  const now = Date.now();
  if (now - state.lastTypingUpdate < CONFIG.TYPING_COOLDOWN_MS) {
    return;
  }
  state.lastTypingUpdate = now;

  if (state.typingTimeout) {
    clearTimeout(state.typingTimeout);
    state.typingTimeout = null;
  }

  try {
    const typingDocRef = doc(state.db, "typingStatus", state.currentUserId);
    await setDoc(typingDocRef, {
      isTyping: isTyping,
      timestamp: Date.now()
    });

    if (isTyping) {
      state.typingTimeout = setTimeout(() => {
        updateTypingStatus(false);
      }, CONFIG.TYPING_TIMEOUT);
    }
  } catch (e) {
    console.error('Typing status error:', e);
  }
}, 300);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER FEED
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderFeed(docs, type, snapshot, isRerender, isFirstSnapshot = false) {
  if (!feedContainer) return;

  // Close any open reaction pickers
  document.querySelectorAll(".reaction-picker").forEach(p => p.remove());

  // Handle notifications for new messages
  if (!isRerender && snapshot) {
    snapshot.docChanges().forEach((change) => {
      if (change.type === "added") {
        const data = change.doc.data();
        const msgTime = data.timestamp ? data.timestamp.toMillis() : 0;
        const isNewMessage = msgTime > appStartTime;
        const isHidden = data.hiddenFor?.includes(state.currentUserId);

        if (isNewMessage &&
          (document.visibilityState === "hidden" || state.currentPage !== type) &&
          data.userId !== state.currentUserId &&
          !isHidden) {
          showNotification(
            type === "chat" ? "New Chat" : "New Confession",
            data.text?.substring(0, 100) || "New message"
          );
        }
      }
    });
  }

  const prevScrollTop = feedContainer.scrollTop;
  const wasAtBottom = state.userIsAtBottom;

  feedContainer.innerHTML = "";

  if (docs.length === 0) {
    const emptyDiv = document.createElement("div");
    emptyDiv.id = "loading";
    emptyDiv.className = "text-center p-4 text-[#888888] text-sm";
    emptyDiv.textContent = `NO ${type.toUpperCase()} YET. BE THE FIRST!`;
    feedContainer.appendChild(emptyDiv);
    return;
  }

  // Show "load more" indicator if there are more messages
  if (state.hasMoreMessages && docs.length >= CONFIG.MESSAGES_PER_PAGE) {
    const loadMoreDiv = document.createElement('div');
    loadMoreDiv.className = 'text-center p-2 text-[#666] text-xs cursor-pointer hover:text-white transition';
    loadMoreDiv.textContent = 'â†‘ Scroll up to load more messages â†‘';
    loadMoreDiv.onclick = loadMoreMessages;
    feedContainer.appendChild(loadMoreDiv);
  }

  let lastUserId = null;
  let lastDateString = null;

  docs.forEach((docInstance) => {
    const data = docInstance.data();

    // Skip hidden messages
    if (data.hiddenFor?.includes(state.currentUserId)) {
      return;
    }

    const text = data.text || "...";
    const messageDateObj = data.timestamp ? data.timestamp.toDate() : new Date();
    const messageDateStr = messageDateObj.toDateString();

    const docUserId = data.userId;

    // Request profile if not loaded
    if (docUserId && !state.userProfiles[docUserId]) {
      requestUserProfile(docUserId);
    }

    if (data.replyTo?.userId && !state.userProfiles[data.replyTo.userId]) {
      requestUserProfile(data.replyTo.userId);
    }

    // Date separator
    if (lastDateString !== messageDateStr) {
      const sepDiv = document.createElement('div');
      sepDiv.className = 'date-separator';

      const sepSpan = document.createElement('span');
      sepSpan.textContent = getDateHeader(messageDateObj);
      sepDiv.appendChild(sepSpan);

      feedContainer.appendChild(sepDiv);
      lastDateString = messageDateStr;
      lastUserId = null;
    }

    const profile = state.userProfiles[docUserId] || {};
    const username = profile.username || "Anonymous";
    const firstChar = (username[0] || "?").toUpperCase();
    const photoURL = profile.profilePhotoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(firstChar)}&background=random&size=64`;

    const isMine = state.currentUserId && docUserId === state.currentUserId;
    const isConsecutive = docUserId && docUserId === lastUserId;
    lastUserId = docUserId;

    const userColor = getUserColor(docUserId);

    // Create message structure
    const alignWrapper = document.createElement("div");
    alignWrapper.className = `flex w-full ${isMine ? "justify-end" : "justify-start"}`;

    const row = document.createElement("div");
    row.className = "message-wrapper";

    const bubble = document.createElement("div");
    bubble.className = `message-bubble rounded-lg max-w-xs sm:max-w-md md:max-w-lg ${isMine ? "my-message" : ""}`;

    if (data.isPinned) {
      bubble.classList.add("pinned");
    }

    // Set data attributes
    bubble.dataset.id = docInstance.id;
    bubble.dataset.text = text;
    bubble.dataset.isMine = String(isMine);
    bubble.dataset.userId = docUserId || '';
    bubble.dataset.username = username;
    bubble.dataset.isPinned = String(data.isPinned || false);
    bubble.dataset.timestamp = data.timestamp ? String(data.timestamp.toMillis()) : String(Date.now());

    // Apply user color styling
    if (!isMine) {
      bubble.style.borderLeft = `3px solid ${userColor}`;
      bubble.style.background = `linear-gradient(90deg, ${userColor}10, transparent)`;
    } else {
      bubble.style.borderRight = `3px solid ${userColor}`;
      bubble.style.background = `linear-gradient(270deg, ${userColor}10, transparent)`;
    }

    // Handle selection mode
    if (state.isSelectionMode && state.selectedMessages.has(docInstance.id)) {
      bubble.classList.add("selected-message");
    }

    bubble.addEventListener('click', (e) => {
      if (state.isSelectionMode) {
        e.preventDefault();
        e.stopPropagation();
        handleMessageClick(bubble);
      }
    });

    // Kebab menu button
    const kebabBtn = document.createElement("button");
    kebabBtn.type = "button";
    kebabBtn.className = "kebab-btn";
    kebabBtn.setAttribute("aria-label", "Message options");
    kebabBtn.appendChild(createKebabIcon());

    kebabBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      showDropdownMenu(e, bubble.dataset);
    });

    // Header with avatar and username (for non-consecutive messages)
    if (!isConsecutive) {
      const headerElement = document.createElement("div");
      headerElement.className = `flex items-center gap-1.5 mb-1 ${isMine ? "justify-end" : "justify-start"}`;

      const imgElement = document.createElement("img");
      imgElement.src = photoURL;
      imgElement.alt = "";
      imgElement.className = `chat-pfp ${isMine ? "order-2" : "order-1"}`;
      imgElement.loading = "lazy";
      imgElement.draggable = false;

      if (!isMine) imgElement.style.borderColor = userColor;

      imgElement.onerror = function () {
        this.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=random&size=64`;
      };

      const usernameElement = document.createElement("div");
      usernameElement.className = `font-bold text-sm opacity-90 ${isMine ? "order-1 text-right" : "order-2 text-left"}`;
      usernameElement.textContent = username;

      if (!isMine) usernameElement.style.color = userColor;

      headerElement.appendChild(imgElement);
      headerElement.appendChild(usernameElement);

      bubble.appendChild(headerElement);
    }

    // Reply preview
    if (data.replyTo) {
      const replyPreview = document.createElement("div");
      replyPreview.className = "reply-preview";

      const replyAuthorEl = document.createElement("div");
      replyAuthorEl.className = "reply-author";
      replyAuthorEl.textContent = state.userProfiles[data.replyTo.userId]?.username || "Anonymous";

      if (!isMine) {
        replyPreview.style.borderLeftColor = userColor;
        replyAuthorEl.style.color = userColor;
      }

      const replyTextEl = document.createElement("div");
      replyTextEl.className = "reply-text";
      replyTextEl.textContent = data.replyTo.text;

      replyPreview.appendChild(replyAuthorEl);
      replyPreview.appendChild(replyTextEl);

      replyPreview.addEventListener("click", (e) => {
        e.stopPropagation();
        const escapedId = escapeSelector(data.replyTo.messageId);
        const originalBubble = document.querySelector(`.message-bubble[data-id="${escapedId}"]`);

        if (originalBubble) {
          originalBubble.scrollIntoView({ behavior: "smooth", block: "center" });
          originalBubble.style.backgroundColor = "rgba(255, 255, 255, 0.1)";

          setTimeout(() => {
            originalBubble.style.backgroundColor = "";
          }, 1000);
        }
      });

      bubble.appendChild(replyPreview);
    }

    // Message text
    const textElement = document.createElement("p");
    textElement.className = "text-left";

    if (data.isPinned) {
      const pinIcon = document.createElement("span");
      pinIcon.className = "text-amber-400 mr-1";
      pinIcon.setAttribute("aria-hidden", "true");
      pinIcon.textContent = "ğŸ“Œ";
      textElement.appendChild(pinIcon);
    }

    textElement.appendChild(document.createTextNode(text));
    bubble.appendChild(textElement);

    // Footer with timestamp
    const footerDiv = document.createElement("div");
    footerDiv.className = "bubble-footer";
    footerDiv.style.justifyContent = isMine ? "flex-end" : "flex-start";

    const timeElement = document.createElement("span");
    timeElement.className = "inner-timestamp";
    timeElement.dataset.ts = data.timestamp ? String(data.timestamp.toMillis()) : String(Date.now());

    let timeText = formatMessageTime(messageDateObj);
    if (data.edited) timeText += " (edited)";
    timeElement.textContent = timeText;

    footerDiv.appendChild(timeElement);
    bubble.appendChild(footerDiv);

    // Reactions
    const docReactions = data.reactions || {};

    const chipsContainer = document.createElement("div");
    chipsContainer.className = "reaction-chips-container";

    let hasChips = false;

    Object.keys(REACTION_TYPES).forEach(rtype => {
      const userIds = docReactions[rtype] || [];

      if (userIds.length > 0) {
        hasChips = true;

        const chip = document.createElement("div");
        chip.className = "reaction-chip";

        const hasReacted = userIds.includes(state.currentUserId);
        if (hasReacted) chip.classList.add("user-reacted");

        const emojiSpan = document.createElement("span");
        emojiSpan.textContent = REACTION_TYPES[rtype];

        const countSpan = document.createElement("span");
        countSpan.textContent = ` ${userIds.length}`;

        chip.appendChild(emojiSpan);
        chip.appendChild(countSpan);

        chip.onclick = (e) => {
          e.stopPropagation();
          toggleReaction(docInstance.id, type, rtype, hasReacted);
        };

        chipsContainer.appendChild(chip);
      }
    });

    if (hasChips) {
      bubble.appendChild(chipsContainer);
      bubble.classList.add("has-reactions");
    }

    // Reply button
    const replyBtn = document.createElement("button");
    replyBtn.type = "button";
    replyBtn.className = "side-action-btn";
    replyBtn.setAttribute("aria-label", "Reply to message");
    replyBtn.textContent = "â†©";

    replyBtn.onclick = (e) => {
      e.stopPropagation();
      startReplyMode(bubble.dataset);
    };

    // React button
    const reactBtn = document.createElement("button");
    reactBtn.type = "button";
    reactBtn.className = "side-action-btn";
    reactBtn.setAttribute("aria-label", "Add reaction");
    reactBtn.textContent = "â™¡";

    const picker = document.createElement("div");
    picker.className = "reaction-picker hidden";
    picker.setAttribute("role", "menu");

    Object.entries(REACTION_TYPES).forEach(([rtype, emoji]) => {
      const opt = document.createElement("span");
      opt.className = "reaction-option";
      opt.setAttribute("role", "menuitem");
      opt.textContent = emoji;

      opt.onclick = (e) => {
        e.stopPropagation();
        const hasReacted = (docReactions[rtype] || []).includes(state.currentUserId);
        toggleReaction(docInstance.id, type, rtype, hasReacted);
        picker.classList.add("hidden");
        picker.remove();
      };

      picker.appendChild(opt);
    });

    reactBtn.onclick = (e) => {
      e.stopPropagation();

      // Close other pickers
      document.querySelectorAll(".reaction-picker").forEach(p => {
        p.classList.add("hidden");
        p.remove();
      });

      const rect = reactBtn.getBoundingClientRect();
      picker.style.top = `${rect.top - 60}px`;

      if (window.innerWidth < 640) {
        picker.style.left = "50%";
        picker.style.transform = "translateX(-50%)";
      } else {
        picker.style.left = `${rect.left}px`;
      }

      picker.classList.remove("hidden");
      document.body.appendChild(picker);
    };

    // Assemble message wrapper
    const bubbleWrapper = document.createElement("div");
    bubbleWrapper.className = `bubble-wrapper ${isMine ? "my-bubble-wrapper" : ""} ${isConsecutive ? "mt-0.5" : "mt-2"}`;

    bubbleWrapper.appendChild(kebabBtn);
    bubbleWrapper.appendChild(bubble);

    if (isMine) {
      row.appendChild(reactBtn);
      row.appendChild(replyBtn);
      row.appendChild(bubbleWrapper);
    } else {
      row.appendChild(bubbleWrapper);
      row.appendChild(replyBtn);
      row.appendChild(reactBtn);
    }

    alignWrapper.appendChild(row);
    feedContainer.appendChild(alignWrapper);
  });

  // Scroll anchor for intersection observer
  const scrollAnchor = document.createElement("div");
  scrollAnchor.id = "scrollAnchor";
  scrollAnchor.style.height = "4px";
  scrollAnchor.style.width = "100%";
  scrollAnchor.style.flexShrink = "0";
  feedContainer.appendChild(scrollAnchor);

  if (state.bottomObserver) {
    state.bottomObserver.disconnect();
    state.bottomObserver.observe(scrollAnchor);
  }

  // Handle scrolling
  const hasNewMessages = snapshot &&
    snapshot.docChanges().some(change => change.type === 'added');

  if (isFirstSnapshot && docs.length > 0) {
    feedContainer.style.scrollBehavior = "auto";
    scrollToBottom();

    requestAnimationFrame(() => {
      scrollToBottom();
      feedContainer.style.scrollBehavior = "smooth";
    });
  } else if (hasNewMessages) {
    const lastDoc = docs[docs.length - 1];
    const isOwnMessage = lastDoc && lastDoc.data().userId === state.currentUserId;

    if (isOwnMessage || wasAtBottom) {
      scrollToBottom();
    } else {
      state.unreadMessages++;
      updateScrollButton();
    }
  } else {
    feedContainer.scrollTop = prevScrollTop;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MESSAGE POSTING (Using Cloud Functions)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function postMessage(collectionRef, input) {
  if (!state.db || !state.currentUserId) {
    showToast("Not connected. Please refresh.", "error");
    return;
  }

  if (state.currentUsername === "Anonymous") {
    showToast("Please set a username first!", "error");
    openProfileModal();
    return;
  }

  if (state.isDeviceBanned) {
    showToast("Your device has been banned.", "error");
    return;
  }

  if (state.isBanned) {
    showToast("You have been banned.", "error");
    return;
  }

  // Client-side rate limiting (additional layer)
  const clientCheck = canSendMessageClientSide();
  if (!clientCheck.allowed) {
    showToast(clientCheck.message, "error");
    return;
  }

  const validation = validateMessageBeforePost(input.value);

  if (!validation.valid) {
    showToast(validation.error, "error");
    input.focus({ preventScroll: true });
    return;
  }

  const text = validation.text;
  const isChat = collectionRef === state.chatCollection;
  const collectionName = isChat ? "chat" : "confessions";

  const submitBtn = isChat
    ? document.getElementById('chatButton')
    : document.getElementById('confessionButton');

  const inputToRefocus = input;

  const resetUI = () => {
    if (input) {
      input.disabled = false;
    }
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.classList.remove('loading');
      submitBtn.textContent = isChat ? 'SEND âœˆï¸' : 'POST âœï¸';
    }
  };

  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.classList.add('loading');
    submitBtn.textContent = 'SENDING...';
  }
  if (input) {
    input.disabled = true;
  }

  try {
    const messageData = {
      text: text,
      collection: collectionName
    };

    if (state.replyToMessage) {
      messageData.replyTo = {
        messageId: state.replyToMessage.id,
        userId: state.replyToMessage.userId,
        text: (state.replyToMessage.text || '').substring(0, 500)
      };
    }

    // Use Cloud Function for message sending (server-side rate limiting)
    if (state.sendMessageFn) {
      await withTimeout(
        state.sendMessageFn(messageData),
        CONFIG.REQUEST_TIMEOUT_MS,
        null
      );
    } else {
      // Fallback to direct write if Cloud Function not available
      // Note: This should only happen if Cloud Functions aren't deployed
      console.warn('Cloud Function not available, using direct write');
      
      const batch = writeBatch(state.db);
      
      const messageRef = doc(collectionRef);
      const msgData = {
        text: text,
        timestamp: serverTimestamp(),
        userId: state.currentUserId,
      };

      if (state.replyToMessage) {
        msgData.replyTo = {
          messageId: state.replyToMessage.id,
          userId: state.replyToMessage.userId,
          text: (state.replyToMessage.text || '').substring(0, 500)
        };
      }

      batch.set(messageRef, msgData);

      const userRef = doc(state.db, "users", state.currentUserId);
      batch.update(userRef, {
        lastMessageAt: serverTimestamp(),
        messageCount: increment(1)
      });

      await batch.commit();
    }

    recordMessageSent();

    if (input) {
      input.value = "";
    }

    cancelReplyMode();
    updateTypingStatus(false);
    scrollToBottom();

    const counter = isChat ? chatCharCount : confessionCharCount;
    if (counter) {
      updateCharacterCounter(input, counter);
    }

    resetUI();

    requestAnimationFrame(() => {
      if (inputToRefocus) {
        inputToRefocus.focus({ preventScroll: true });
      }
    });

  } catch (error) {
    console.error('Send message error:', error);

    if (error.code === 'functions/resource-exhausted') {
      showToast("Please wait before sending another message.", "error");
    } else if (error.code === 'functions/permission-denied' || error.code === 'permission-denied') {
      showToast("Permission denied. You may be banned.", "error");
    } else if (error.code === 'functions/failed-precondition') {
      showToast("Please set a username first.", "error");
      openProfileModal();
    } else if (error.code === 'unavailable' || error.code === 'functions/unavailable') {
      showToast("Server unavailable. Please try again.", "error");
    } else {
      showToast("Failed to send message. Please try again.", "error");
    }

    resetUI();

    requestAnimationFrame(() => {
      if (inputToRefocus) {
        inputToRefocus.focus({ preventScroll: true });
      }
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REPLY MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function startReplyMode(messageData) {
  const repliedUserId = messageData.userId ||
    (messageData.isMine === "true" ? state.currentUserId : null);

  state.replyToMessage = {
    id: messageData.id,
    userId: repliedUserId,
    text: messageData.text
  };

  const repliedUsername = state.userProfiles[repliedUserId]?.username || "Anonymous";

  setTextSafely(replyAuthor, `Replying to ${repliedUsername}`);
  setTextSafely(replyText, state.replyToMessage.text);

  if (replyBar) {
    replyBar.classList.add("show");
  }

  const input = state.currentPage === "chat" ? chatInput : confessionInput;
  if (input) input.focus();
}

function cancelReplyMode() {
  state.replyToMessage = null;

  if (replyBar) {
    replyBar.classList.remove("show");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENT LISTENERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Prevent keyboard flickering on desktop
if (window.matchMedia('(hover: hover)').matches) {
  document.getElementById('chatButton')?.addEventListener('mousedown', (e) => {
    e.preventDefault();
  }, { passive: false });

  document.getElementById('confessionButton')?.addEventListener('mousedown', (e) => {
    e.preventDefault();
  }, { passive: false });
}

// Close reaction pickers and context menu when clicking outside
document.addEventListener("click", (e) => {
  if (!e.target.closest(".side-action-btn") && !e.target.closest(".reaction-picker")) {
    document.querySelectorAll(".reaction-picker").forEach(p => {
      p.classList.add("hidden");
      p.remove();
    });
  }

  if (!contextMenu?.contains(e.target) && !e.target.closest(".kebab-btn")) {
    hideDropdownMenu();
  }
});

// Update timestamps every minute
setInterval(() => {
  document.querySelectorAll('.inner-timestamp').forEach(el => {
    const ts = parseInt(el.dataset.ts, 10);
    if (ts > 0) {
      const isEdited = el.textContent.includes("(edited)");
      el.textContent = formatMessageTime(new Date(ts)) + (isEdited ? " (edited)" : "");
    }
  });
}, 60000);

// Scroll button
scrollToBottomBtn?.addEventListener("click", scrollToBottom);

// Form submissions
confessionForm?.addEventListener("submit", (e) => {
  e.preventDefault();
  e.stopPropagation();
  postMessage(state.confessionsCollection, confessionInput);
});

chatForm?.addEventListener("submit", (e) => {
  e.preventDefault();
  e.stopPropagation();
  postMessage(state.chatCollection, chatInput);
});

// Navigation
navConfessions?.addEventListener("click", () => showPage("confessions"));
navChat?.addEventListener("click", () => showPage("chat"));

navConfessions?.addEventListener("keydown", (e) => {
  if (e.key === "Enter" || e.key === " ") {
    e.preventDefault();
    showPage("confessions");
  }
});

navChat?.addEventListener("keydown", (e) => {
  if (e.key === "Enter" || e.key === " ") {
    e.preventDefault();
    showPage("chat");
  }
});

// Profile modal
profileButton?.addEventListener("click", openProfileModal);
modalCloseButton?.addEventListener("click", closeProfileModal);
modalSaveButton?.addEventListener("click", handleProfileSave);

// Edit modal
editModalCancelButton?.addEventListener("click", closeEditModal);
editModalSaveButton?.addEventListener("click", saveEdit);

// Confirm modal
confirmModalNoButton?.addEventListener("click", closeConfirmModal);

// Context menu actions
menuEdit?.addEventListener("click", () => {
  if (state.currentContextMenuData) {
    showEditModal(
      state.currentContextMenuData.id,
      state.currentPage,
      state.currentContextMenuData.text
    );
  }
  hideDropdownMenu();
});

menuDelete?.addEventListener("click", () => {
  if (state.currentContextMenuData) {
    const isMine = state.currentContextMenuData.isMine === "true";
    showConfirmModal(
      isMine ? "Delete this message?" : "Hide this message?",
      isMine,
      state.currentContextMenuData.id
    );
  }
  hideDropdownMenu();
});

menuSelect?.addEventListener("click", () => {
  enterSelectionMode();
  hideDropdownMenu();
});

// Selection mode
selectionCancel?.addEventListener("click", exitSelectionMode);
selectionDelete?.addEventListener("click", handleMultiDelete);

// Reply bar
cancelReply?.addEventListener("click", cancelReplyMode);

// Input event handlers
confessionInput?.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    postMessage(state.confessionsCollection, confessionInput);
  } else {
    updateTypingStatus(true);
  }
});

chatInput?.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    postMessage(state.chatCollection, chatInput);
  } else {
    updateTypingStatus(true);
  }
});

chatInput?.addEventListener("input", () => {
  updateTypingStatus(true);
  updateCharacterCounter(chatInput, chatCharCount);
});

confessionInput?.addEventListener("input", () => {
  updateTypingStatus(true);
  updateCharacterCounter(confessionInput, confessionCharCount);
});

// Keyboard shortcuts
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    if (profileModal?.classList.contains("is-open")) {
      closeProfileModal();
    } else if (editModal?.classList.contains("is-open")) {
      closeEditModal();
    } else if (confirmModal?.classList.contains("is-open")) {
      closeConfirmModal();
    } else if (contextMenu?.classList.contains("is-open")) {
      hideDropdownMenu();
    } else if (state.isSelectionMode) {
      exitSelectionMode();
    } else if (state.replyToMessage) {
      cancelReplyMode();
    }
  }
});

// Visibility change handler
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    if (state.userIsAtBottom) {
      state.unreadMessages = 0;
      updateScrollButton();
    }
  }
});

// Before unload - clear typing status
window.addEventListener("beforeunload", () => {
  if (state.db && state.currentUserId) {
    updateTypingStatus(false);
  }
});

// Cleanup on page unload
window.addEventListener('unload', () => {
  cleanupAllListeners();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZE APP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

initFirebase().catch(err => {
  console.error('Init error:', err);
  setTextSafely(loading, "Error: Failed to initialize. Please refresh the page.");
  hideBanCheckOverlay();
});
  