rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================
    // KONVO - ANONYMOUS CHAT PLATFORM SECURITY RULES
    // Version: 6.0 (Cloud Function Integrated)
    // 
    // SECURITY MODEL:
    // - All rate limiting handled by Cloud Functions
    // - Client cannot modify rate limit fields
    // - Minimal client-side write permissions
    // - Server-side validation for sensitive operations
    // ============================================================

    // ============================
    // 1. HELPER FUNCTIONS
    // ============================

    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    // Check if user is banned
    function isBanned() {
      return isSignedIn() &&
             exists(/databases/$(database)/documents/banned_users/$(request.auth.uid));
    }

    // Check if user is active (signed in and not banned)
    function isActiveUser() {
      return isSignedIn() && !isBanned();
    }

    // Check if user is an admin
    function isAdmin() {
      return isSignedIn() &&
             !isBanned() &&
             exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    // Check if user has a profile
    function hasUserProfile() {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    // ============================
    // 2. VALIDATION FUNCTIONS
    // ============================

    // Validate message text content
    function isValidText(text) {
      return text is string
             && text.size() > 0
             && text.size() <= 500;
    }

    // Validate server timestamp
    function isServerTimestamp() {
      return request.resource.data.timestamp == request.time;
    }

    // Validate collection name
    function isValidCollection(col) {
      return col in ['chat', 'confessions'];
    }

    // Validate username format
    function isValidUsername(username) {
      return username is string
             && username.size() >= 1
             && username.size() <= 30
             && username.matches('^[a-zA-Z0-9_\\- ]+$')
             && username.matches('.*[a-zA-Z0-9]+.*')
             && !username.matches('^\\s.*')
             && !username.matches('.*\\s$')
             // Reserved words check
             && username.lower() != 'anonymous'
             && username.lower() != 'admin'
             && username.lower() != 'moderator'
             && username.lower() != 'system'
             && username.lower() != 'konvo'
             && username.lower() != 'mod'
             && username.lower() != 'support'
             && username.lower() != 'staff'
             && username.lower() != 'official'
             && username.lower() != 'root'
             && username.lower() != 'owner'
             && username.lower() != 'bot'
             && username.lower() != 'help'
             && !username.lower().matches('.*anonymous.*')
             && !username.lower().matches('.*admin.*')
             && !username.lower().matches('.*moderator.*')
             && !username.lower().matches('.*konvo.*')
             && !username.lower().matches('.*support.*')
             && !username.lower().matches('.*staff.*')
             && !username.lower().matches('.*official.*');
    }

    // Validate profile photo URL (only allowed domains)
    function isValidProfilePhotoURL(url) {
      return url is string
             && url.size() <= 500
             && (
               url.matches('^https://placehold\\.co/.*')
               || url.matches('^https://ui-avatars\\.com/.*')
               || url.matches('^https://api\\.dicebear\\.com/.*')
             );
    }

    // ============================
    // 3. USER PROFILE VALIDATION
    // ============================

    // CRITICAL: Users can ONLY set username and profilePhotoURL
    // All other fields (lastMessageAt, deviceCount, etc.) are SERVER-ONLY
    function isValidUserProfileCreate() {
      let data = request.resource.data;
      let allowedFields = ['username', 'profilePhotoURL', 'createdAt'];
      
      return data.keys().hasOnly(allowedFields)
             && 'username' in data
             && isValidUsername(data.username)
             && (!('profilePhotoURL' in data) || isValidProfilePhotoURL(data.profilePhotoURL))
             && (!('createdAt' in data) || data.createdAt == request.time);
    }

    // User profile update - STRICT field control
    // Users can ONLY update username and profilePhotoURL
    // Server-controlled fields are explicitly blocked
    function isValidUserProfileUpdate() {
      let data = request.resource.data;
      let oldData = resource.data;
      let changedFields = data.diff(oldData).affectedKeys();
      
      // ONLY these fields can be changed by users
      let userEditableFields = ['username', 'profilePhotoURL'];
      
      // These fields are SERVER-ONLY (Cloud Functions)
      let serverOnlyFields = [
        'lastMessageAt',
        'lastReactionAt', 
        'lastDeviceReg',
        'lastTypingAt',
        'banned',
        'trustLevel',
        'messageCount',
        'deviceCount',
        'updatedAt'
      ];
      
      // Check that only user-editable fields are being changed
      let onlyUserFields = changedFields.hasOnly(userEditableFields);
      
      // Validate the actual changes
      let validUsername = !('username' in changedFields) || isValidUsername(data.username);
      let validPhoto = !('profilePhotoURL' in changedFields) || isValidProfilePhotoURL(data.profilePhotoURL);
      
      // Explicitly ensure NO server-only fields are being modified
      let noServerFields = !changedFields.hasAny(serverOnlyFields);
      
      return onlyUserFields && validUsername && validPhoto && noServerFields;
    }

    // Admin user create (for banning)
    function isValidAdminUserCreate() {
      let data = request.resource.data;
      return data.keys().hasOnly(['banned'])
             && data.banned is bool;
    }

    // Admin user update
    function isValidAdminUserUpdate() {
      let data = request.resource.data;
      let changedFields = data.diff(resource.data).affectedKeys();
      let adminAllowedFields = ['banned', 'trustLevel', 'messageCount', 'deviceCount'];
      
      return changedFields.hasOnly(adminAllowedFields)
             && (!('banned' in changedFields) || data.banned is bool)
             && (!('trustLevel' in changedFields) || (data.trustLevel is int && data.trustLevel >= 0 && data.trustLevel <= 10));
    }

    // ============================
    // 4. MESSAGE VALIDATION
    // ============================

    // Validate reply structure
    function isValidReplyTo(replyTo) {
      return replyTo is map
             && replyTo.keys().hasOnly(['messageId', 'userId', 'text'])
             && replyTo.messageId is string
             && replyTo.messageId.size() > 0
             && replyTo.messageId.size() <= 100
             && replyTo.userId is string
             && replyTo.userId.size() > 0
             && replyTo.userId.size() <= 128
             && replyTo.text is string
             && replyTo.text.size() <= 200;
    }

    // Message create validation (for direct client writes - backup only)
    // Primary message creation should go through Cloud Function
    function isValidMessageCreate() {
      let data = request.resource.data;
      let allowedFields = ['text', 'timestamp', 'userId', 'replyTo'];
      
      return data.keys().hasOnly(allowedFields)
             && data.userId == request.auth.uid
             && isValidText(data.text)
             && isServerTimestamp()
             && (!('replyTo' in data) || isValidReplyTo(data.replyTo));
    }

    // Message edit validation (own messages only, within 15 minutes)
    function isValidMessageEdit() {
      let data = request.resource.data;
      let oldData = resource.data;
      let changedFields = data.diff(oldData).affectedKeys();
      
      return changedFields.hasOnly(['text', 'edited'])
             && 'text' in changedFields
             && data.edited == true
             && data.userId == oldData.userId
             && data.timestamp == oldData.timestamp
             && oldData.timestamp is timestamp
             && oldData.timestamp + duration.value(15, 'm') > request.time
             && isValidText(data.text);
    }

    // Hidden for user validation
    function isValidHiddenForUpdate() {
      let oldHiddenFor = resource.data.get('hiddenFor', []);
      let newHiddenFor = request.resource.data.get('hiddenFor', []);
      
      return newHiddenFor is list
             && newHiddenFor.size() <= 1000
             && newHiddenFor.hasAll(oldHiddenFor)
             && newHiddenFor.size() == oldHiddenFor.size() + 1
             && request.auth.uid in newHiddenFor
             && !(request.auth.uid in oldHiddenFor);
    }

    // Admin message update (pinning)
    function isValidAdminMessageUpdate() {
      let data = request.resource.data;
      let changedFields = data.diff(resource.data).affectedKeys();
      
      return changedFields.hasOnly(['isPinned'])
             && data.isPinned is bool;
    }

    // ============================
    // 5. REACTION VALIDATION (Read-only from client)
    // Reactions should go through Cloud Function for rate limiting
    // ============================

    // Backup validation if direct writes are needed
    // FIXED: Removed if statement - functions can only have let + return
    function isValidReactionsUpdate() {
      let oldReactions = resource.data.get('reactions', {});
      let newReactions = request.resource.data.reactions;
      let validTypes = ['thumbsup', 'laugh', 'surprised', 'heart', 'skull'];
      let uid = request.auth.uid;
      
      // Basic structure validation
      let validStructure = newReactions is map
             && newReactions.keys().hasOnly(validTypes);
      
      // Validate each reaction array
      let validArrays = validateReactionArrays(newReactions);
      
      // Validate user can only change their own reaction
      let validUserChange = validateUserReactionChange(oldReactions, newReactions, uid);
      
      // Validate other users' reactions are unchanged
      let othersUnchanged = validateOtherUsersUnchanged(oldReactions, newReactions, uid);
      
      // Use && short-circuit instead of if statement
      return validStructure && validArrays && validUserChange && othersUnchanged;
    }

    function validateReactionArrays(reactions) {
      return (!('thumbsup' in reactions) || (reactions.thumbsup is list && reactions.thumbsup.size() <= 500))
             && (!('laugh' in reactions) || (reactions.laugh is list && reactions.laugh.size() <= 500))
             && (!('surprised' in reactions) || (reactions.surprised is list && reactions.surprised.size() <= 500))
             && (!('heart' in reactions) || (reactions.heart is list && reactions.heart.size() <= 500))
             && (!('skull' in reactions) || (reactions.skull is list && reactions.skull.size() <= 500));
    }

    function validateUserReactionChange(oldReactions, newReactions, uid) {
      let thumbsupDiff = getReactionDiff(oldReactions, newReactions, 'thumbsup', uid);
      let laughDiff = getReactionDiff(oldReactions, newReactions, 'laugh', uid);
      let surprisedDiff = getReactionDiff(oldReactions, newReactions, 'surprised', uid);
      let heartDiff = getReactionDiff(oldReactions, newReactions, 'heart', uid);
      let skullDiff = getReactionDiff(oldReactions, newReactions, 'skull', uid);
      
      let totalChanges = thumbsupDiff + laughDiff + surprisedDiff + heartDiff + skullDiff;
      // User can only add OR remove one reaction at a time
      return totalChanges == 1 || totalChanges == -1;
    }

    function getReactionDiff(oldReactions, newReactions, reactionType, uid) {
      let oldList = oldReactions.get(reactionType, []);
      let newList = newReactions.get(reactionType, []);
      let wasIn = uid in oldList;
      let isIn = uid in newList;
      
      return (wasIn && !isIn) ? -1 : (!wasIn && isIn) ? 1 : 0;
    }

    function validateOtherUsersUnchanged(oldReactions, newReactions, uid) {
      return validateSingleReactionOthersUnchanged(oldReactions, newReactions, 'thumbsup', uid)
             && validateSingleReactionOthersUnchanged(oldReactions, newReactions, 'laugh', uid)
             && validateSingleReactionOthersUnchanged(oldReactions, newReactions, 'surprised', uid)
             && validateSingleReactionOthersUnchanged(oldReactions, newReactions, 'heart', uid)
             && validateSingleReactionOthersUnchanged(oldReactions, newReactions, 'skull', uid);
    }

    function validateSingleReactionOthersUnchanged(oldReactions, newReactions, reactionType, uid) {
      let oldList = oldReactions.get(reactionType, []);
      let newList = newReactions.get(reactionType, []);
      let oldWithoutUser = oldList.removeAll([uid]);
      let newWithoutUser = newList.removeAll([uid]);
      
      return oldWithoutUser.size() == newWithoutUser.size()
             && oldWithoutUser.hasAll(newWithoutUser)
             && newWithoutUser.hasAll(oldWithoutUser);
    }

    // ============================
    // 6. BAN RECORD VALIDATION
    // ============================

    function isValidBanRecord() {
      let data = request.resource.data;
      let requiredFields = ['bannedBy', 'timestamp'];
      let allAllowedFields = ['bannedBy', 'timestamp', 'reason', 'username'];
      
      return data.keys().hasAll(requiredFields)
             && data.keys().hasOnly(allAllowedFields)
             && data.bannedBy == request.auth.uid
             && data.timestamp == request.time
             && (!('reason' in data) || (data.reason is string && data.reason.size() <= 500))
             && (!('username' in data) || (data.username is string && data.username.size() <= 30));
    }

    function isValidDeviceBanRecord() {
      let data = request.resource.data;
      let requiredFields = ['fingerprint', 'bannedBy', 'timestamp'];
      let allAllowedFields = ['fingerprint', 'userId', 'username', 'bannedBy', 'timestamp', 'reason', 'userAgent', 'platform'];
      
      return data.keys().hasAll(requiredFields)
             && data.keys().hasOnly(allAllowedFields)
             && data.fingerprint is string
             && data.fingerprint.size() > 0
             && data.fingerprint.size() <= 100
             && data.bannedBy == request.auth.uid
             && data.timestamp == request.time
             && (!('userId' in data) || (data.userId is string && data.userId.size() <= 128))
             && (!('username' in data) || (data.username is string && data.username.size() <= 30))
             && (!('reason' in data) || (data.reason is string && data.reason.size() <= 500))
             && (!('userAgent' in data) || data.userAgent == null || (data.userAgent is string && data.userAgent.size() <= 500))
             && (!('platform' in data) || data.platform == null || (data.platform is string && data.platform.size() <= 100));
    }

    function isValidIPBanRecord() {
      let data = request.resource.data;
      let requiredFields = ['bannedBy', 'timestamp', 'ipHash'];
      let allAllowedFields = ['ipHash', 'userId', 'username', 'bannedBy', 'timestamp', 'reason'];
      
      return data.keys().hasAll(requiredFields)
             && data.keys().hasOnly(allAllowedFields)
             && data.bannedBy == request.auth.uid
             && data.timestamp == request.time
             && data.ipHash is string
             && data.ipHash.size() > 0
             && data.ipHash.size() <= 64
             && (!('userId' in data) || (data.userId is string && data.userId.size() <= 128))
             && (!('username' in data) || (data.username is string && data.username.size() <= 30))
             && (!('reason' in data) || (data.reason is string && data.reason.size() <= 500));
    }

    // ============================
    // 7. PINNED MESSAGE VALIDATION
    // ============================

    function isValidPinnedMessage() {
      let data = request.resource.data;
      let requiredFields = ['originalId', 'collection', 'text', 'pinnedBy', 'timestamp'];
      
      return data.keys().hasAll(requiredFields)
             && data.keys().hasOnly(requiredFields)
             && data.originalId is string
             && data.originalId.size() > 0
             && data.originalId.size() <= 100
             && data.collection in ['chat', 'confessions']
             && data.text is string
             && data.text.size() <= 200
             && data.pinnedBy == request.auth.uid
             && data.timestamp == request.time;
    }

    // ============================
    // 8. COLLECTION RULES
    // ============================

    // --- Users Collection ---
    match /users/{userId} {
      // Anyone signed in can read user profiles
      allow read: if isSignedIn();

      // Create: User can create their own profile OR admin can create
      allow create: if (
                      isActiveUser()
                      && request.auth.uid == userId
                      && isValidUserProfileCreate()
                    ) || (
                      isAdmin()
                      && isValidAdminUserCreate()
                    );

      // Update: User can update their own profile (limited fields) OR admin
      allow update: if (
                      isActiveUser()
                      && request.auth.uid == userId
                      && isValidUserProfileUpdate()
                    ) || (
                      isAdmin()
                      && isValidAdminUserUpdate()
                    );

      allow delete: if isAdmin();
    }

    // --- Typing Status Collection ---
    // DISABLED for direct client writes - use Cloud Function
    match /typingStatus/{docId} {
      allow read: if isSignedIn();
      
      // Only allow if writing to own document with valid structure
      // Rate limiting handled by Cloud Function
      allow write: if isActiveUser()
                   && request.auth.uid == docId
                   && request.resource.data.keys().hasOnly(['isTyping', 'timestamp'])
                   && request.resource.data.isTyping is bool
                   && request.resource.data.timestamp is int
                   && request.resource.data.timestamp > 0;
    }

    // --- Rate Limits Collection (Server-only) ---
    match /rate_limits/{docId} {
      allow read: if isAdmin() || (isSignedIn() && docId.matches('^' + request.auth.uid + '_.*'));
      allow write: if false; // Cloud Functions only
    }

    // --- Banned Users Collection ---
    match /banned_users/{oduserId} {
      allow read: if isAdmin() ||
                  (isSignedIn() && request.auth.uid == oduserId);

      allow create: if isAdmin() && isValidBanRecord();

      allow update: if isAdmin();

      allow delete: if isAdmin();
    }

    // --- Banned Devices Collection ---
    match /banned_devices/{fingerprintId} {
      allow read: if isAdmin() ||
                  (isSignedIn() && 
                   exists(/databases/$(database)/documents/user_devices/$(request.auth.uid + '_' + fingerprintId)));

      allow create: if isAdmin() && isValidDeviceBanRecord();

      allow update: if isAdmin();

      allow delete: if isAdmin();
    }

    // --- Banned IPs Collection ---
    match /banned_ips/{ipHashId} {
      // Only admins can read banned IPs (security)
      allow read: if isAdmin();

      allow create: if isAdmin() && isValidIPBanRecord();

      allow update: if isAdmin();

      allow delete: if isAdmin();
    }

    // --- User Devices Collection ---
    // Device registration should go through Cloud Function
    match /user_devices/{deviceDocId} {
      allow read: if isAdmin() ||
                  (isSignedIn() && deviceDocId.matches('^' + request.auth.uid + '_.*'));

      // DISABLED: Direct device registration
      // All device registration must go through registerDevice Cloud Function
      allow create: if false;
      
      // Allow updates only for lastSeen (from Cloud Function via client SDK not possible)
      allow update: if false;

      allow delete: if isAdmin();
    }

    // --- Pinned Messages Collection ---
    match /pinned_messages/{docId} {
      allow read: if isSignedIn();

      allow create: if isAdmin() && isValidPinnedMessage();

      allow update: if isAdmin();

      allow delete: if isAdmin();
    }

    // --- Admin List Collection ---
    match /admins/{oduserId} {
      allow read: if isSignedIn() && request.auth.uid == oduserId;

      allow write: if false; // Manual management only
    }

    // --- Chat & Confessions Collections ---
    match /{collection}/{docId} {
      allow read: if isValidCollection(collection) && isSignedIn();

      // Create: Messages should go through Cloud Function
      // This is a fallback for backward compatibility
      allow create: if isValidCollection(collection)
                    && isActiveUser()
                    && hasUserProfile()
                    && isValidMessageCreate();

      // Update: Edit own messages, hide messages, admin actions
      allow update: if isValidCollection(collection)
                    && !isBanned()
                    && (
                      // Admin can pin/unpin
                      (
                        isAdmin()
                        && isValidAdminMessageUpdate()
                      )
                      ||
                      // Owner can edit within 15 minutes
                      (
                        isActiveUser()
                        && resource.data.userId == request.auth.uid
                        && isValidMessageEdit()
                      )
                      ||
                      // Reactions - should use Cloud Function, but allow as fallback
                      (
                        isActiveUser()
                        && request.resource.data.diff(resource.data)
                           .affectedKeys()
                           .hasOnly(['reactions'])
                        && isValidReactionsUpdate()
                      )
                      ||
                      // Hide for self
                      (
                        isActiveUser()
                        && request.resource.data.diff(resource.data)
                           .affectedKeys()
                           .hasOnly(['hiddenFor'])
                        && isValidHiddenForUpdate()
                      )
                    );

      // Delete: Owner or admin can delete
      allow delete: if isValidCollection(collection)
                    && !isBanned()
                    && (
                      (isActiveUser() && resource.data.userId == request.auth.uid)
                      ||
                      isAdmin()
                    );
    }

    // --- CAPTCHA Verifications (Server-only) ---
    match /captcha_verifications/{docId} {
      allow read: if false;
      allow write: if false;
    }

    // --- Catch-all Deny ---
    match /{document=**} {
      allow read, write: if false;
    }
  }
}