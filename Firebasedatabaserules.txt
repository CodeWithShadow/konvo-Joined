rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================
    // ANONYMOUS CHAT PLATFORM SECURITY RULES
    // ============================================================
    // Users are auto-signed in via Firebase Anonymous Auth.
    // No login form required - but each user gets a unique UID.
    // This allows banning, rate limiting, and tracking without 
    // requiring email/password.
    // ============================================================

    // ============================
    // 1. HELPER FUNCTIONS
    // ============================

    // Anonymous users ARE signed in (via signInAnonymously)
    function isSignedIn() {
      return request.auth != null;
    }

    // Check if user is banned (lookup in banned_users collection)
    function isBanned() {
      return isSignedIn() &&
             exists(/databases/$(database)/documents/banned_users/$(request.auth.uid));
    }

    // Active user = signed in (anonymous) + NOT banned
    function isActiveUser() {
      return isSignedIn() && !isBanned();
    }

    // ADMIN CHECK - CRITICAL SECURITY
    // Admin status is determined ONLY by existence in /admins collection
    // /admins can ONLY be modified via Firebase Console (allow write: if false)
    // Even if a hacker knows an admin UID, they cannot grant themselves admin
    // Banned admins lose their powers (security measure)
    function isAdmin() {
      return isSignedIn() &&
             !isBanned() &&
             exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    // Validate message text (anti-spam/exploit)
    function isValidText() {
      return request.resource.data.text is string
             && request.resource.data.text.size() > 0
             && request.resource.data.text.size() < 2000;
    }

    // Force server timestamp (prevents timestamp manipulation)
    function isNow() {
      return request.resource.data.timestamp == request.time;
    }

    // Whitelist valid collections
    function isValidCollection(col) {
      return col in ['chat', 'confessions'];
    }

    // Rate limit: 1 message per 2 seconds per user
    // Requires app.js to update lastMessageAt on each message send
    function canSendMessage() {
      return isActiveUser() && (
        !exists(/databases/$(database)/documents/users/$(request.auth.uid)) ||
        !('lastMessageAt' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data) ||
        get(/databases/$(database)/documents/users/$(request.auth.uid))
          .data.lastMessageAt + duration.value(2, 's') < request.time
      );
    }

    // SECURITY: User profile validation
    // CRITICAL: 'banned' field is NOT in allowedFields - users CANNOT modify their ban status
    // Only admins can set the banned field (handled in admin write rule)
    function isValidUserProfile() {
      let allowedFields = ['username', 'profilePhotoURL', 'lastMessageAt'];
      return request.resource.data.keys().hasOnly(allowedFields)
             && (!('username' in request.resource.data) || 
                 (request.resource.data.username is string && 
                  request.resource.data.username.size() > 0 && 
                  request.resource.data.username.size() <= 30))
             && (!('profilePhotoURL' in request.resource.data) || 
                 (request.resource.data.profilePhotoURL is string &&
                  request.resource.data.profilePhotoURL.size() < 500))
             && (!('lastMessageAt' in request.resource.data) ||
                 request.resource.data.lastMessageAt == request.time);
    }

    // Typing status validation
    function isValidTypingStatus() {
      let allowedFields = ['isTyping', 'timestamp'];
      return request.resource.data.keys().hasOnly(allowedFields)
             && request.resource.data.isTyping is bool
             && request.resource.data.timestamp is number;
    }

    // hiddenFor validation - users can ONLY hide messages for themselves
    function isValidHiddenForUpdate() {
      let oldHiddenFor = resource.data.get('hiddenFor', []);
      let newHiddenFor = request.resource.data.get('hiddenFor', []);
      return newHiddenFor.hasAll(oldHiddenFor) 
             && newHiddenFor.size() == oldHiddenFor.size() + 1
             && request.auth.uid in newHiddenFor
             && !(request.auth.uid in oldHiddenFor);
    }

    // Validate allowed fields for new messages
    function isValidMessageCreate() {
      let allowedFields = ['text', 'timestamp', 'userId', 'replyTo'];
      return request.resource.data.keys().hasOnly(allowedFields);
    }

    // ============================
    // 2. SPECIFIC COLLECTIONS
    // ============================

    // --- USERS (Profiles) ---
    match /users/{userId} {
      // Any signed-in user can read profiles (needed for usernames)
      allow read: if isSignedIn();

      // Regular users: can ONLY edit their OWN profile with valid fields
      // CANNOT set 'banned' field (not in allowedFields)
      allow create: if isActiveUser() 
                    && request.auth.uid == userId 
                    && isValidUserProfile();
      
      // Update: Either user editing own profile OR admin setting banned status
      allow update: if (
                      // Option A: User editing their own profile
                      isActiveUser() 
                      && request.auth.uid == userId 
                      && isValidUserProfile()
                      && !('banned' in request.resource.data)
                    ) || (
                      // Option B: Admin setting banned field on any user
                      isAdmin()
                    );

      // Only admins can delete user profiles
      allow delete: if isAdmin();
    }

    // --- TYPING STATUS ---
    match /typingStatus/{userId} {
      allow read: if isSignedIn();
      
      allow write: if isActiveUser() &&
                   request.auth.uid == userId &&
                   isValidTypingStatus();
    }

    // --- BANNED USERS ---
    // CRITICAL: Only admins can ban/unban
    match /banned_users/{odId} {
      // Users can check if they're banned (for client-side message)
      // Admins can see all bans
      allow read: if isAdmin() ||
                  (isSignedIn() && request.auth.uid == odId);

      // ONLY admins can create/update/delete bans
      // A banned user CANNOT unban themselves (isAdmin checks !isBanned)
      allow write: if isAdmin();
    }

    // --- PINNED MESSAGES ---
    match /pinned_messages/{docId} {
      allow read: if isSignedIn();
      
      // Only admins can pin/unpin
      allow write: if isAdmin();
    }

    // --- ADMIN LIST ---
    // MAXIMUM SECURITY: No client can EVER write to this collection
    // Admins can only be added via Firebase Console or Admin SDK
    match /admins/{docId} {
      // Only existing admins can see the admin list
      allow read: if isAdmin();

      // ABSOLUTE BLOCK: No client-side writes allowed
      // This prevents ANY exploit from granting admin access
      allow write: if false;
    }

    // ============================
    // 3. CHAT & CONFESSIONS
    // ============================

    match /{collection}/{docId} {

      // Read: signed-in users only
      allow read: if isValidCollection(collection) && isSignedIn();

      // CREATE: Rate-limited message posting
      allow create: if isValidCollection(collection)
                    && canSendMessage()
                    && isValidText()
                    && isValidMessageCreate()
                    && request.resource.data.userId == request.auth.uid
                    && isNow();

      // UPDATE: Multiple scenarios
      allow update: if isValidCollection(collection)
                    && !isBanned()
                    && (
                      // ADMIN: Full control
                      isAdmin()
                      ||
                      // AUTHOR: Edit own message (text, edited flag only)
                      // Cannot change userId or timestamp
                      (
                        isSignedIn()
                        && resource.data.userId == request.auth.uid
                        && request.resource.data.userId == resource.data.userId
                        && request.resource.data.timestamp == resource.data.timestamp
                        && request.resource.data.diff(resource.data)
                           .affectedKeys()
                           .hasOnly(['text', 'edited'])
                      )
                      ||
                      // ANY USER: Add reactions
                      (
                        isSignedIn()
                        && request.resource.data.diff(resource.data)
                           .affectedKeys()
                           .hasOnly(['reactions'])
                        && request.resource.data.reactions is map
                      )
                      ||
                      // ANY USER: Hide message for themselves only
                      (
                        isSignedIn()
                        && request.resource.data.diff(resource.data)
                           .affectedKeys()
                           .hasOnly(['hiddenFor'])
                        && request.resource.data.hiddenFor is list
                        && isValidHiddenForUpdate()
                      )
                    );

      // DELETE: Author or admin only
      allow delete: if isValidCollection(collection)
                    && !isBanned()
                    && (
                      (isSignedIn() && resource.data.userId == request.auth.uid)
                      || isAdmin()
                    );
    }

    // ============================
    // 4. CATCH-ALL DENY
    // ============================
    // Block ALL other collections/documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
